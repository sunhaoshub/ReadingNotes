# 大小端转换函数

本地一般是小端存储，传输时按照大端存储；

发送数据时，将小端转化为大端，接收时将大端转化为小端；

转换IP地址：

hton, ntoh

# tcp/ip通信流程

![img](https://subingwen.cn/linux/socket/tcp.jpg)

# 基本函数

## socket

```c++
int socket(int domain,int type,int protocol);
/*
domain:指定地址族协议，AF_INET,AF_INET6,AF_LOCAL
type:指定传输协议：SOCK_STREAM，流式协议 SOCK_DGRAM 报式协议
protpcol：第二个参数为流式协议，0是tcp，第二个参数为报式协议，0是udp
*/
```

## bind

将套接字与本地端口绑定，且必须转化成**大端存储**；

```C++
int bind(int sockfd,const struct sockaddr* addr,socklen_t adddrlen);
/*
struct sockaddr{
	sa_family_t sa_family;//地址组协议 ipv4
	char sa_data[14];//端口2字节+IP地址4字节+填充8字节
}
赋值时不好用

struct sockaddr_in
{
	sa_family_t sa_family;//地址组协议 ipv4
	in_port_t sin_port;//端口
	struct in_addr sin_addr;//IP地址,结构体里面就是一个整型数 s_addr 宏 INADDR_ANY 自动绑定本地网卡IP地址
	...填充
}
*/
```

## listen

```C++
int listen(int sockfd,int backlog);
//backlog 最多监听多少个连接
```

## accept

默认阻塞，直到有新的客户端连接

建立一个新的文件描述符并返回

```C++
int accept(int sockfd,struct sockaddr* addr,socketlen_t *adderlen)
/*
	addr:传出参数，存储客户端的相关信息
*/
```

## connect

客户端发起连接请求的函数

```C++
int connect(int sockfd,const struct sockaddr* addr,socketlen_t* addrlen);
//addr:服务器的IP和端口信息
```

## 服务端客户端通信函数

### read/recv write/send

读取/接收数据，返回值为0表示已经断开连接，-1表示失败

## 网络通信demo

client.c

```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>

int main()
{
    // 1. 创建通信的套接字
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if(fd == -1)
    {
        perror("socket");
        exit(0);
    }

    // 2. 连接服务器
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9999);   // 大端端口
    inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr.s_addr);

    int ret = connect(fd, (struct sockaddr*)&addr, sizeof(addr));
    if(ret == -1)
    {
        perror("connect");
        exit(0);
    }

    // 3. 和服务器端通信
    int number = 0;
    while(1)
    {
        // 发送数据
        char buf[1024];
        sprintf(buf, "你好, 服务器...%d\n", number++);
        write(fd, buf, strlen(buf)+1);
        
        // 接收数据
        memset(buf, 0, sizeof(buf));
        int len = read(fd, buf, sizeof(buf));
        if(len > 0)
        {
            printf("服务器say: %s\n", buf);
        }
        else if(len  == 0)
        {
            printf("服务器断开了连接...\n");
            break;
        }
        else
        {
            perror("read");
            break;
        }
        sleep(1);   // 每隔1s发送一条数据
    }

    close(fd);

    return 0;
}
```

server.c

```C++
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<arpa/inet.h>

int main()
{
    //1.创建监听套接字
    int fd = socket(AF_INET,SOCK_STREAM,0);
    if(fd == -1)
    {
        perror("socket");
        return;
    }   
    //2.绑定套接字
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9999);
    addr.sin_addr.s_addr = INADDR_ANY;

    int ret = bind(fd,(struct sockaddr *)&addr,sizeof(addr));
    if(ret == -1)
    {
        perror("bind");
        return;
    }
    //3.监听套接字
    ret = listen(fd,128);
    if(ret == -1)
    {
        perror("listen");
        return;
    }

    //4.阻塞等待客户端连接
    struct sockaddr_in cliaddr;
    int clilen = sizeof(struct sockaddr_in);
    int cfd = accept(fd,(struct sockaddr*)&cliaddr,&clilen);
    if(cfd == -1)
    {
        perror("accept");
        return ;
    }

    //5.读取客户端发送的数据
    char ip[24] = {0};
    printf("客户端的IP地址 = %s,端口：%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,sizeof(ip)),ntohs(cliaddr.sin_port));

    while (1)
    {
        char buf[1024];
        memset(buf,0,sizeof(buf));
        int len = recv(cfd,buf,sizeof(buf),0);
        if(len > 0)
        {
            printf("客户端say: %s\n", buf);
            send(cfd, buf, len,0);
        }
        else if(len  == 0)
        {
            printf("客户端断开了连接...\n");
            break;
        }
        else
        {
            perror("read");
            break;
        }
    }
    
}

```

## 基于多线程的服务器

客户端在主线程进行accept操作，一旦accept，就创建一个新的子线程，在结束时调用pthread_join会导致阻塞，无法实现并发，所以需要使用线程分离

server:

```C++
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<arpa/inet.h>
#include<pthread.h>

//作为子线程工作函数参数传入
struct SockInfo
{
    int fd;
    struct sockaddr_in addr;
};
struct SockInfo infos[512];


void* working(void* arg)
{
    struct SockInfo* pinfo = (struct SockInfo*)arg;
    //5.读取客户端发送的数据
    char ip[24] = {0};
    printf("客户端的IP地址 = %s,端口：%d\n",inet_ntop(AF_INET,&pinfo->addr.sin_addr.s_addr,ip,sizeof(ip)),
    ntohs(pinfo->addr.sin_port));

    while (1)
    {
        char buf[1024];
        memset(buf,0,sizeof(buf));
        int len = recv(pinfo->fd,buf,sizeof(buf),0);
        if(len > 0)
        {
            printf("客户端say: %s\n", buf);
            send(pinfo->fd, buf, len,0);
        }
        else if(len  == 0)
        {
            printf("客户端断开了连接...\n");
            return -1;
        }
        else
        {
            perror("read");
            return -1;
        }
    }

    close(pinfo->fd);
    pinfo->fd = -1;
    return NULL;
}

int main()
{
    //1.创建监听套接字
    int fd = socket(AF_INET,SOCK_STREAM,0);
    if(fd == -1)
    {
        perror("socket");
        exit(0);
    }   
    //2.绑定套接字
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(10002);
    addr.sin_addr.s_addr = INADDR_ANY;

    int ret = bind(fd,(struct sockaddr *)&addr,sizeof(addr));
    if(ret == -1)
    {
        perror("bind");
        exit(0);
    }
    //3.监听套接字
    ret = listen(fd,128);
    if(ret == -1)
    {
        perror("listen");
        return -1;
    }

    int max = sizeof(infos)/sizeof(infos[0]);
    for(int i = 0;i < max;i++)
    {
        bzero(&infos[i],sizeof(infos[i]));
        infos[i].fd = -1;
    }

    //4.循环等待客户端连接
    int len = sizeof(struct sockaddr_in);
    while (1)
    {
        struct SockInfo* pinfo;
        for(int i = 0;i < max;i++)
        {
            if(infos[i].fd == -1)
            {
                pinfo = &infos[i];
                break;
            }
        }
        int cfd = accept(fd,(struct sockaddr*)&pinfo->addr,&len);
        pinfo->fd = cfd;
        if(cfd == -1)
        {
            perror("accept");
            break;;
        }

        //接收子线程客户端连接成功后，创建子线程处理任务
        pthread_t tid;
        pthread_create(&tid,NULL,working,pinfo);
        pthread_detach(tid);
    }
    

    close(fd);
    return 0;
    
}
```

client

```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>

int main()
{
    // 1. 创建通信的套接字
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if(fd == -1)
    {
        perror("socket");
        exit(0);
    }

    // 2. 连接服务器
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9999);   // 大端端口
    inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr.s_addr);

    int ret = connect(fd, (struct sockaddr*)&addr, sizeof(addr));
    if(ret == -1)
    {
        perror("connect");
        exit(0);
    }

    // 3. 和服务器端通信
    int number = 0;
    while(1)
    {
        // 发送数据
        char buf[1024];
        sprintf(buf, "你好, 服务器...%d\n", number++);
        write(fd, buf, strlen(buf)+1);
        
        // 接收数据
        memset(buf, 0, sizeof(buf));
        int len = read(fd, buf, sizeof(buf));
        if(len > 0)
        {
            printf("服务器say: %s\n", buf);
        }
        else if(len  == 0)
        {
            printf("服务器断开了连接...\n");
            break;
        }
        else
        {
            perror("read");
            break;
        }
        sleep(1);   // 每隔1s发送一条数据
    }

    close(fd);

    return 0;
}
```

# Qt网络通信

用到两个类：QTcpServer和QTcpSocket

* QTcpServer，用于服务端，用于监听和建立连接，使用时需要在pro文件中添加network模块
* QTcpSocket，通信套接字类



信号：newConnection()，当有新连接建立的时候，会发出该信号，在槽函数中调用nextPendingConnection()函数建立连接



客户端使用connectToHost()函数与服务端建立连接



通信过程中对数据的读写都是对本地内存的读写，这块内存是Qt框架帮助我们维护的

## 通信流程

服务端：

* 创建套接字服务器QTcpServer对象
* 通过QTcpSerer对象设置监听，即QTcpServer::listen()
* 基于QTcpServer::newConnection()信号检测是否有新的客户端连接
* 如果有新的客户端连接，调用QTcpSocket* QTcpServer::nextPendingConnection()得到通信的套接字对象
* 使用QTcpSocket和客户端通信

客户端：

* 创建QTcpSocket对象
* 使用服务端绑定的IP和端口连接服务器QAbstractSocket::connectToHost()
* 使用QTcpSocket对象和服务器进行通信

# IO多路复用

accept、read、write函数是互斥阻塞的

## select

* 通过fd_set数组来设置文件描述符，该数组以位为单位，如果是1，表示被监视
* 操作fd_set数组的宏“

```
FD_ZERO(fd_set* fd)
FD_SET(int fd,fd_set* fd)
FD_CLR(int fd,fd_set* fd)
FD_ISSET(int fd,fd_set* fd)
```

