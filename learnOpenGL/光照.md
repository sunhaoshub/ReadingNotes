# 颜色

我们在生活中看到的颜色不是物体本身具有的颜色，而是它反射的颜色；即那些不能被物体吸收的颜色，就是我们感知到的物体的颜色

![img](https://learnopengl-cn.github.io/img/02/01/light_reflection.png)

当我们在OpenGL中创建一个光源时，我们将其设置为白色。当我们把光源的颜色和物体的颜色相乘，所得到的就是这个物体所反射的颜色（即我们感知的颜色）

```C++
glm::vec3 lightColor(1.0f,1.0f,1.0f);//纯白
glm::vec3 toyColor(1,0f,0.5f,0.31f);
glm::vec3 result = lightColor * toyColor;
```

## 创建一个光照场景

将光源显示为一个可见物体

首先需要创建一个物体作为被投光的对象

# 基础光照

冯氏光照模型，主要由三个分量组成：环境（Ambient）、漫反射（Diffuse）和镜面（Specular）光照

* 环境光照：即使在黑暗的情况下，世界上通常也会有一些光亮，所以物体几乎不会是永远黑暗的。为了模拟，我们会使用一个环境光照常量，它永远会给物体一些颜色
* 漫反射光照：模拟光源对物体的方向性影响
* 镜面光照：模拟有光泽物体上的亮点。镜面光照的颜色相比于物体的颜色更倾向于光的颜色

## 环境光照

全局光照算法：把光照射到别的物体上反射的光产生的间接影响也考虑进去

我们当前使用一个简化的全局光照模型，即只有一个光源，并且给他指定一个很小的系数

片段着色器：

```C++
void main()
{
    float ambientStrength = 0.1;
    FragColor = vec4(ambientStrength*lightColor*objectColor,1.0f);
}
```

![image-20240123144521141](C:\Users\sunha\Desktop\book\ReadingNotes\learnOpenGL\光照.assets\image-20240123144521141.png)

## 漫反射光照

通过法向量来评估漫反射强度

计算漫反射需要的因素：

* 法向量
* 定向的光线

## 计算漫反射光照

声明光源位置

```glsl
uniform vec3 lightPos;//片段着色器
```

更新uniform

```C++
lightingShader.setVec3("lightPos",lightPos);
```

计算光源和片段之间的位置向量

```glsl
vec3 norm = normalize(Normal);
vec3 lightDir = normalize(lightPos-FragPos);
```

计算漫反射效果

```glsl
float diff = max(dot(norm,lightDir),0.0);
vec3 diffuse = diff*lightColor; 
```

获得环境光照和漫反射叠加的效果

```glsl
vec3 result = (ambient+diffuse)*objectColor;
FragColor = vec4(result,1.0f);
```

2.1.light_cube.vs

```glsl
#version 330 core
layout (location=0) in vec3 aPos;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
	gl_Position = projection * view * model * vec4(aPos,1.0f);
}
```

2.1.light_cube.fs

```glsl
#version 330 core
out vec4 FragColor;

void main()
{
	FragColor = vec4(1.0f);
}
```

2.1.basic_lighting.vs

```glsl
#version 330 core
layout (location=0) in vec3 aPos;
layout (location=1) in vec3 aNormal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 Normal;
out vec3 FragPos;

void main()
{
	FragPos = vec3(model*vec4(aPos,1.0f));
	gl_Position = projection*view* vec4(FragPos,1.0f);
	Normal = aNormal;
}
```

2.1.bsic_lighting.fs

```glsl
#version 330 core

out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;

uniform vec3 lightPos;
uniform vec3 lightColor;
uniform vec3 objectColor;


void main()
{
	float ambientStrength = 0.1;
	vec3 ambient = ambientStrength*lightColor;
	
	vec3 norm = normalize(Normal);
	vec3 lightDir = normalize(lightPos-FragPos);

	float diff = max(dot(norm,lightDir),0.0);
	vec3 diffuse = diff*lightColor;

	vec3 result =(ambient+diffuse)*objectColor;
	FragColor = vec4(result,1.0);  
}
```

## 最后一件事

法向量已经从顶点着色器传到片段着色器，但是片段着色器的计算都是在世界空间坐标中进行的，所以需要把法向量转化为世界空间坐标；

法向量只是一个坐标，不能表达空间中特定的位置；其次，法向量也没有齐次坐标，因此，位移影响不到法向量。需要在模型矩阵中剔除位移部分。对于法向量，我们只希望对它进行位移和旋转操作；

在对物体表面施加一个不等比缩放时，会影响物体的形状，进而影响法线方向；

通过法线矩阵来修复这个行为

```glsl
Normal = mat3(transpose(inverse(model))) * aNormal;
```

## 镜面光照

![img](https://learnopengl-cn.github.io/img/02/02/basic_lighting_specular_theory.png)

根据法向量翻折入射光的方向来计算**反射向量**，然后计算反射向量和观察方向的角度差，，它们之间夹角越小，镜面光的作用越大。由此会产生高光的效果

通过观察者的世界空间位置和片段位置来计算观察向量

定义观察者位置

```glsl
uniform vec3 viewPos;
```

传递给着色器

```c++
lightingShader.setVec3("viewPos", camera.Position);
```

定义镜面光照强度

```glsl
float specularStrength = 0.5;
```

计算视线方向向量和对应的反射光向量

其中要reflect方向是光源指向片段的方向

```glsl
vec3 viewDir = normalize(viewPos-FragPos);
vec3 reflectDir = reflect(-lightDir,norm);
```

计算镜面分量

```glsl
float spec = pow(max(dot(viewDir,reflectDir),0),32);
vec3 spectular = specularStrength*spec*lightColor;
```

# 材质
