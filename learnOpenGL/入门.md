



GLFW：针对OpenGL的C语言库，提供了一些渲染物体所需的最低限度的接口；

GLAD：OpenGL只是一个规范，具体实现由驱动厂家针对显卡指定的，大多数函数无法在编译阶段确定，需要在运行阶段查询；所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。GLAD是一个开源的库，它能解决我们上面提到的那个繁琐的问题。

```C++
#include <glad/glad.h> 
#include<GLFW/glfw3.h>
#include<iostream>

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0, 0, width, height);
}

void pressInput(GLFWwindow* window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}

int main()
{
    //初始化
    glfwInit();
    //配置
    //主版本号
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    //次版本号
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    //核心模式，OpenGL的一个子集
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow* window = glfwCreateWindow(800, 600, "learnOpenGL", NULL, NULL);
    if (window == NULL)
    {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }

    glViewport(0, 0, 800, 600);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    while (!glfwWindowShouldClose(window))
    {
        pressInput(window);

        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);


        glfwSwapBuffers(window);
        glfwPollEvents();
    }
    glfwTerminate();

    return 0;
}
```

3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。



# 绘制一个窗口

* 初始化GLFW
* 指定OpenGL的主、次版本号和核心模式
* 创建窗口并返回指针，将当前线程设置为主线程
* 通过GLAD管理OpenGL指针
* 进行视口变换
* 开始渲染







![img](https://learnopengl-cn.github.io/img/01/04/pipeline.png)

# 三角形

## 绘制三角形步骤

* 定义顶点
* 定义并绑定顶点缓冲区对象VBO
* 将数据绑定到VBO
* 创建着色器对象（顶点着色器、片段着色器）
* 将两个着色器对象链接成着色器程序对象并激活
* 链接顶点属性并启用

## 1.顶点输入

仅当3D坐标的范围在-1.0-1.0之间时OpenGL才会处理它，超过这个范围则不会处理

指定顶点

```C++
float vertices[] =
    {
        -0.5f, -0.5f, 0.0f,
         0.5f, -0.5f, 0.0f,
         0.0f,  0.5f, 0.0f
    };
```



将顶点作为输入传送给顶点着色器，它会在GPU上创建内存**存储顶点**，要配置OpenGL如何解释这些内存，并且指定如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。

通过顶点缓冲对象（VBO）来管理这些内存，VBO有一个独一无二的ID，可以使用glGenBuffers函数和一个缓冲区ID来生成一个VBO对象

```c++
unsigned int VBO;
glGenBuffers(1,&VBO);
```

OpenGL 中有很多对象缓冲模型，VBO只是其中的一种；OpenGL允许绑定多个不同的对象模型，使用函数`glBindBuffer`

```C++
glBindBuffer(GL_ARRAY_BUFFER,VBO);
```

调用glBufferData函数，将数据复制到缓冲区；

```
第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：
GL_STATIC_DRAW ：数据不会或几乎不会改变。
GL_DYNAMIC_DRAW：数据会被改变很多。
GL_STREAM_DRAW ：数据每次绘制时都会改变。
```

```C++
glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);
```

## 2.顶点着色器

用着色器语言GLSL写着色器，然后编译

```
//版本
#version 330 core
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
```

在运行时动态编译着色器的源代码

用类似创建VBO的方法来创建着色器对象

```C++
unsigned int vertexShader;
vertexShader = glCreateShader(GL_VERTEX_SHADER);
```

将着色器源码附着到着色器对象上并编译它

```C++
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
glCompileShader(vertexShader);
```

## 3.片段着色器

功能：计算像素最后的颜色输出

```C++
const char* fragmentShaderSource =
        "#version 330 core\n"
        "out vec4 FragColor;\n"
        "void main()\n"
        "{\n"
        "    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
        "} \0"
        ;
    unsigned int fragmentShader;
    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);
```

### 着色器程序

着色器程序对象是多个着色器合并并且链接之后得到的结果

创建一个着色器程序对象

```C++
unsigned int shaderProgram;
shaderProgram = glCreateProgram();
```

将之前创建的着色器对象添加到程序对象中并链接

```C++
glAttachShader(shaderProgram, verterShader);
glAttachShader(shaderProgram, fragmentShader);
glLinkProgram(shaderProgram);
```

激活程序对象

```C++
glUseProgram(shaderProgram);
```

删除着色器对象

```C++
glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
```

现在，我们已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL还不知道它该**如何解释**内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。

## 4.链接顶点属性

顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。

![img](https://learnopengl-cn.github.io/img/01/04/vertex_attribute_pointer.png)

使用`glVertexAttribPointer`函数告诉OpenGL如何解析这些顶点属性

```C++
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
//启用顶点属性，默认是禁用
glEnableVertexAttribArray(0);
```

```
glVertexAttribPointer参数：
参数1：指定要配置的顶点属性，在顶点着色器中使用layout(location=0)定义了顶点属性的位置值，可以把顶点属性的位置值设为0
参数2：指定定点参数的大小
参数3：数据类型
参数4：是否标准化
参数5：步长，定义了连续顶点属性的间隔
```

当顶点和物体很多的时候，为每个物体匹配顶点会很麻烦，需要将状态配置存储在一个对象中，并通过对象来恢复状态

### 顶点数组对象VAO

一个VAO存储有：

- glEnableVertexAttribArray和glDisableVertexAttribArray的调用。
- 通过glVertexAttribPointer设置的顶点属性配置。
- 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。

![img](https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png)
