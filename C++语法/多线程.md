进程有独立的地址空间，线程是多个共用一个地址空间

在一个地址空间中，每个线程独享栈区和寄存器，多个线程共享代码端、堆区、全局数据区、文件描述表；

线程是程序执行的最小单位，进程是资源分配的最小单位

上下文切换通过寄存器实现

# 创建线程

创建了子线程后，原来的进程退化为主线程

需要头文件pthread.h

编译的时候加 -l pthread

```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

void* callback()
{
    printf("child_thread = %d\n",pthread_self());
    for(int i = 0;i < 10;i++)
    {
        printf("child i = %d\n",i);
    }
    return NULL;
}

int main()
{
    //子线程id
    pthread_t tid;
    //创建子线程
    pthread_create(&tid,NULL,callback,NULL);
    /*
    thread: 传出参数，是无符号长整形数，线程创建成功, 会将线程ID写入到这个指针指向的内存中

    attr: 线程的属性, 一般情况下使用默认属性即可, 写NULL

    start_routine: 函数指针，创建出的子线程的处理动作，也就是该函数在子线程中执行。

    arg: 作为实参传递到 start_routine 指针指向的函数内部，传递多个参数可以使用结构体
    */
    printf("parent_thread = %d\n",pthread_self());
    for(int i = 0;i < 10;i++)
    {
        printf("parent i = %d\n",i);
    }
    //程序执行时间很短导致子线程无法执行的措施
    sleep(3);
    return 0;
}
```

# 线程退出

主线程退出的时候会释放虚拟地址空间，**线程退出函数只会使该线程退出，不影响其他线程的执行**，所有线程执行完之后程序才会退出，主要用于主线程

```C++
void pthread_exit(void* retval);
//要返回的数据，没有可指定为NULL
```

```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

void* callback(void* arg)
{
    printf("子线程ID：%d\n",pthread_self());
    for (int i = 0; i < 10; i++)
    {
        printf("子线程：%d\n",i);
    }
    return NULL;
    
}

int main()
{
    pthread_t tid;
    pthread_create(&tid,NULL,callback,NULL);
    printf("主线程ID：%d\n",pthread_self());
    for (int i = 0; i < 10; i++)
    {
        printf("主线程：%d\n",i);
    }

    pthread_exit(NULL);
}
```



# 线程回收

子线程退出时其内核资源由主线程回收，函数是pthread_join(),该函数是阻塞函数，只要子线程还在运行，调用该函数就会阻塞，子线程退出，函数解除阻塞进行资源的回收,同时主线程阻塞.**函数被调用一次，只能回收一个子线程**，如果有多个子线程需要循环回收；

线程回收函数可以使主线程获取到**子线程退出时传递的数据,通过pthread_exit函数传出**,

```C++
int pthread_join(pthread_t thread,void** retval);
```

## 使用全局变量

```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

struct  Test
{
    int num;
    int age;
};


void* callback(void* arg)
{
    printf("子线程ID：%d\n",pthread_self());
    struct Test *test = (struct Test*)arg;
    test->num = 100;
    test->age = 66;

    for (int i = 0; i < 10; i++)
    {
        printf("子线程：%d\n",i);
    }
    //传出数据，子线程还没有退出，主线程中的join函数接受了test的资源，然后将子线程资源回收，此时数据已经到了主线程中
    pthread_exit(test);

    return NULL;
    
}

int main()
{
    pthread_t tid;
    struct Test t;
    pthread_create(&tid,NULL,callback,&t);
    printf("主线程ID：%d\n",pthread_self());
    for (int i = 0; i < 10; i++)
    {
        printf("主线程：%d\n",i);
    }

    void *ptr;
    pthread_join(tid,&ptr);
    struct Test* test = (struct Test*)ptr;
    printf("num = %d,age = %d\n",test->num,test->age);
}
```

## 使用主线程栈空间

子线程不能访问主线程的空间，但主线程可以传递给子线程

```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

struct Test
{
    int num;
    int age;
};

void* callback(void* arg)
{
    int childThread = pthread_self();
    printf("childThread = %d\n",childThread);
    struct Test *t = (struct Test*)arg;
    t->num = 100;
    t->age = 67;
    pthread_exit(t);
    return NULL;
}

int main()
{
    pthread_t tid;
    struct Test t;
    pthread_create(&tid,NULL,callback,&t);
    printf("parent = %d\n",pthread_self());
    void* ptr;
    pthread_join(tid,&ptr);
    struct Test *res = (struct Test*)ptr;
    printf("num : %d age : %d\n",res->num,res->age);
    printf("子线程资源被成功回收...\n");
    return 0;
}
```

# 线程分离

在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用pthread_join()只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。

在线程库函数中为我们提供了线程分离函数pthread_detach()，调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用pthread_join()就回收不到子线程资源了。

# 互斥锁

创建互斥锁：

```C++
pthread_mutex_t mutex;
```

在创建的锁对象中保存了当前锁的信息；

## 相关操作

```C++
//初始化互斥锁
//restrict：一个关键字，用来修饰指针，只有这个关键字修饰的指针可以访问指向的内存地址，其他指针不行
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                      const pthread_mutexattr_t *restrict attr);
//释放互斥锁资源
int pthread_mutex_destory(pthread_mutex_t* mutex);
```



```C++
//上锁
int pthread_mutex_lock(pthread_mutex_t* mutex);
/*
首先判断参数锁的状态是不是锁定状态
	没有上锁就加锁成功，并且记录哪个线程加锁
	如果被锁定，当前线程就阻塞
	线程通过竞争的方式对这把锁加锁，没竞争到的继续阻塞
*/
//尝试加锁如果失败，不会阻塞，直接返回错误号
int ptherad_mutex_trylock(pthread_mutex_t* mutex);
// 对互斥锁解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```



```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

#define MAX 50
pthread_mutex_t mutex;
int number = 0;

void * callBackA(void* arg)
{
    for (int i = 0;i < MAX ; i++)
    {
        pthread_mutex_lock(&mutex);
        number++;
        printf("线程A,ID = %ld , number = %d;\n",pthread_self(),number);
        sleep(10);
        pthread_mutex_unlock(&mutex);
    }
}

void * callBackB(void* arg)
{
    for (int i = 0;i < MAX ; i++)
    {
        pthread_mutex_lock(&mutex);
        number++;
        printf("线程B,ID = %ld , number = %d;\n",pthread_self(),number);
        sleep(10);
        pthread_mutex_unlock(&mutex);
    }
}

int main()
{
    pthread_t tidA,tidB;
    pthread_mutex_init(&mutex,NULL);

    pthread_create(&tidA,NULL,callBackA,NULL);
    pthread_create(&tidB,NULL,callBackB,NULL);

    pthread_join(tidA,NULL);
    pthread_join(tidB,NULL);

    pthread_mutex_destroy(&mutex);
    
}
```

## 死锁

lock函数上锁失败，对应的线程会阻塞；但是unlock函数只能解锁上锁的函数，对这种失败的线程无法操作；

# 读写锁

所有线程是读操作时，是并行操作的，而互斥锁读取操作也是互斥的

```
pthread_rwlock_t rwlock;
```

写锁的优先级高于读锁

```C++
int pthread_rwlock_rdlock(pthread_rwlock_t * rwlock);
/*
如果之前已经加过读锁了，那么上锁依然可以成功，如果加的是写锁，那么调用这个函数的线程会阻塞，可以使用tryrdlock函数
*/
```

```c++
//解决未定义pthread_rwlock_t的问题
#define _XOPEN_SOURCE 500       
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <bits/pthreadtypes.h>

//定义8个线程，其中3个写，5个读

#define MAX 50

pthread_rwlock_t rwlock;
int number = 0;

void* readNum(void* arg)
{
    for(int i = 0;i < MAX;i++)
    {
        pthread_rwlock_rdlock(&rwlock);
        printf("Thread read,ID = %ld,number = %d\n",pthread_self(),number);
        pthread_rwlock_unlock(&rwlock);
        usleep(rand()%5);
    }
    
}

void* writeNum(void* arg)
{
    for(int i = 0;i <MAX;i++)
    {
        pthread_rwlock_wrlock(&rwlock);
        number++;
        printf("Thread write,ID = %ld,number = %d\n",pthread_self(),number);
        pthread_rwlock_unlock(&rwlock);
        usleep(rand()%5);
    }
}

int main()
{
    pthread_t p1[3],p2[5];
    pthread_rwlock_init(&rwlock,NULL);
    for(int i = 0;i < 3;i++)
    {
        pthread_create(&p1[i],NULL,writeNum,NULL);
    }
    for(int i = 0;i < 5;i++)
    {
        pthread_create(&p2[i],NULL,readNum,NULL);
    }

    for(int i = 0;i < 3;i++)
        pthread_join(p1[i],NULL);
    for(int i = 0;i < 5;i++)
        pthread_join(p2[i],NULL);
    
    pthread_rwlock_destroy(&rwlock);
}
```

# 条件变量

互斥锁做线程同步， 条件变量负责阻塞线程

```C++
pthread_cond_t cond;
```

被条件变量阻塞的线程会被记录到cond变量里，以便解除阻塞时使用；

```C++
//线程阻塞函数，哪个线程调用该函数，哪个线程就会被阻塞
int pthread_cond_wait(pthread_cond_t* restrict cond,pthread_mutex_t* restrict mutex);
/*
在阻塞线程时，如果该线程已经上锁，那么会把锁打开，防止死锁
在解除线程阻塞的时候，函数内部会给该线程上锁，继续向下访问临界区
*/
//唤醒线程函数
int pthread_cond_signal(pthread_cond_t* cond);
```

## 生产者消费者模型

```C++
//解决未定义pthread_rwlock_t的问题
#define _XOPEN_SOURCE 500       
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

pthread_mutex_t mutex;
pthread_cond_t cond;

struct Node
{
    int num;
    struct Node* next;
};
struct Node* head = NULL;

void* producer(void* arg)
{
    while (1)
    {
        pthread_mutex_lock(&mutex);
        //临界区
        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
        newNode->next = head;
        newNode->num = rand()%1000;
        head = newNode;
        printf("producer,ID = %ld,number = %d\n",pthread_self(),newNode->num);
        pthread_mutex_unlock(&mutex);
        pthread_cond_signal(&cond);

        usleep(rand()%5);
    }
    return NULL;
    
}

void* consumer(void* arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);
        while (head == NULL)
        {
            pthread_cond_wait(&cond,&mutex);
        }
        struct Node*pnode = head;
        head= pnode->next;
        printf("consumer,ID = %ld,number = %d\n",pthread_self(),pnode->num);
        free(pnode);
        
        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

int main()
{
    pthread_mutex_init(&mutex,NULL);
    pthread_cond_init(&cond,NULL);

    pthread_t p1[5],p2[5];
    for(int i = 0;i < 5;i++)
        pthread_create(&p1[i],NULL,producer,NULL);
    for (int i = 0; i < 5; i++)
        pthread_create(&p2[i],NULL,consumer,NULL);
    
    for(int i= 0;i <5;i++)
        pthread_join(p1[i],NULL);
    for (int i = 0; i < 5; i++)
        pthread_join(p2[i],NULL);
    

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
}
```

