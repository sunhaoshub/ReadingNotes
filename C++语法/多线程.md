进程有独立的地址空间，线程是多个共用一个地址空间

在一个地址空间中，每个线程独享栈区和寄存器，多个线程共享代码端、堆区、全局数据区、文件描述表；

线程是程序执行的最小单位，进程是资源分配的最小单位

上下文切换通过寄存器实现

# 创建线程

创建了子线程后，原来的进程退化为主线程

需要头文件pthread.h

编译的时候加 -l pthread

```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

void* callback()
{
    printf("child_thread = %d\n",pthread_self());
    for(int i = 0;i < 10;i++)
    {
        printf("child i = %d\n",i);
    }
    return NULL;
}

int main()
{
    //子线程id
    pthread_t tid;
    //创建子线程
    pthread_create(&tid,NULL,callback,NULL);
    /*
    thread: 传出参数，是无符号长整形数，线程创建成功, 会将线程ID写入到这个指针指向的内存中

    attr: 线程的属性, 一般情况下使用默认属性即可, 写NULL

    start_routine: 函数指针，创建出的子线程的处理动作，也就是该函数在子线程中执行。

    arg: 作为实参传递到 start_routine 指针指向的函数内部，传递多个参数可以使用结构体
    */
    printf("parent_thread = %d\n",pthread_self());
    for(int i = 0;i < 10;i++)
    {
        printf("parent i = %d\n",i);
    }
    //程序执行时间很短导致子线程无法执行的措施
    sleep(3);
    return 0;
}
```

# 线程退出

主线程退出的时候会释放虚拟地址空间，**线程退出函数只会使该线程退出，不影响其他线程的执行**，所有线程执行完之后程序才会退出，主要用于主线程

```C++
void pthread_exit(void* retval);
//要返回的数据，没有可指定为NULL
```

```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

void* callback(void* arg)
{
    printf("子线程ID：%d\n",pthread_self());
    for (int i = 0; i < 10; i++)
    {
        printf("子线程：%d\n",i);
    }
    return NULL;
    
}

int main()
{
    pthread_t tid;
    pthread_create(&tid,NULL,callback,NULL);
    printf("主线程ID：%d\n",pthread_self());
    for (int i = 0; i < 10; i++)
    {
        printf("主线程：%d\n",i);
    }

    pthread_exit(NULL);
}
```



# 线程回收

子线程退出时其内核资源由主线程回收，函数是pthread_join(),该函数是阻塞函数，只要子线程还在运行，调用该函数就会阻塞，子线程退出，函数解除阻塞进行资源的回收,同时主线程阻塞.**函数被调用一次，只能回收一个子线程**，如果有多个子线程需要循环回收；

线程回收函数可以使主线程获取到**子线程退出时传递的数据,通过pthread_exit函数传出**,

```C++
int pthread_join(pthread_t thread,void** retval);
```

## 使用全局变量

```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

struct  Test
{
    int num;
    int age;
};


void* callback(void* arg)
{
    printf("子线程ID：%d\n",pthread_self());
    struct Test *test = (struct Test*)arg;
    test->num = 100;
    test->age = 66;

    for (int i = 0; i < 10; i++)
    {
        printf("子线程：%d\n",i);
    }
    //传出数据，子线程还没有退出，主线程中的join函数接受了test的资源，然后将子线程资源回收，此时数据已经到了主线程中
    pthread_exit(test);

    return NULL;
    
}

int main()
{
    pthread_t tid;
    struct Test t;
    pthread_create(&tid,NULL,callback,&t);
    printf("主线程ID：%d\n",pthread_self());
    for (int i = 0; i < 10; i++)
    {
        printf("主线程：%d\n",i);
    }

    void *ptr;
    pthread_join(tid,&ptr);
    struct Test* test = (struct Test*)ptr;
    printf("num = %d,age = %d\n",test->num,test->age);
}
```

## 使用主线程栈空间

子线程不能访问主线程的空间，但主线程可以传递给子线程

```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

struct Test
{
    int num;
    int age;
};

void* callback(void* arg)
{
    int childThread = pthread_self();
    printf("childThread = %d\n",childThread);
    struct Test *t = (struct Test*)arg;
    t->num = 100;
    t->age = 67;
    pthread_exit(t);
    return NULL;
}

int main()
{
    pthread_t tid;
    struct Test t;
    pthread_create(&tid,NULL,callback,&t);
    printf("parent = %d\n",pthread_self());
    void* ptr;
    pthread_join(tid,&ptr);
    struct Test *res = (struct Test*)ptr;
    printf("num : %d age : %d\n",res->num,res->age);
    printf("子线程资源被成功回收...\n");
    return 0;
}
```

# 线程分离

在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用pthread_join()只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。

在线程库函数中为我们提供了线程分离函数pthread_detach()，调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用pthread_join()就回收不到子线程资源了。

# 互斥锁

创建互斥锁：

```C++
pthread_mutex_t mutex;
```

在创建的锁对象中保存了当前锁的信息；

## 相关操作

```C++
//初始化互斥锁
//restrict：一个关键字，用来修饰指针，只有这个关键字修饰的指针可以访问指向的内存地址，其他指针不行
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                      const pthread_mutexattr_t *restrict attr);
//释放互斥锁资源
int pthread_mutex_destory(pthread_mutex_t* mutex);
```



```C++
//上锁
int pthread_mutex_lock(pthread_mutex_t* mutex);
/*
首先判断参数锁的状态是不是锁定状态
	没有上锁就加锁成功，并且记录哪个线程加锁
	如果被锁定，当前线程就阻塞
	线程通过竞争的方式对这把锁加锁，没竞争到的继续阻塞
*/
//尝试加锁如果失败，不会阻塞，直接返回错误号
int ptherad_mutex_trylock(pthread_mutex_t* mutex);
// 对互斥锁解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```



```C++
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

#define MAX 50
pthread_mutex_t mutex;
int number = 0;

void * callBackA(void* arg)
{
    for (int i = 0;i < MAX ; i++)
    {
        pthread_mutex_lock(&mutex);
        number++;
        printf("线程A,ID = %ld , number = %d;\n",pthread_self(),number);
        sleep(10);
        pthread_mutex_unlock(&mutex);
    }
}

void * callBackB(void* arg)
{
    for (int i = 0;i < MAX ; i++)
    {
        pthread_mutex_lock(&mutex);
        number++;
        printf("线程B,ID = %ld , number = %d;\n",pthread_self(),number);
        sleep(10);
        pthread_mutex_unlock(&mutex);
    }
}

int main()
{
    pthread_t tidA,tidB;
    pthread_mutex_init(&mutex,NULL);

    pthread_create(&tidA,NULL,callBackA,NULL);
    pthread_create(&tidB,NULL,callBackB,NULL);

    pthread_join(tidA,NULL);
    pthread_join(tidB,NULL);

    pthread_mutex_destroy(&mutex);
    
}
```

## 死锁

lock函数上锁失败，对应的线程会阻塞；但是unlock函数只能解锁上锁的函数，对这种失败的线程无法操作；

# 读写锁

所有线程是读操作时，是并行操作的，而互斥锁读取操作也是互斥的

```
pthread_rwlock_t rwlock;
```

写锁的优先级高于读锁

```C++
int pthread_rwlock_rdlock(pthread_rwlock_t * rwlock);
/*
如果之前已经加过读锁了，那么上锁依然可以成功，如果加的是写锁，那么调用这个函数的线程会阻塞，可以使用tryrdlock函数
*/
```

```c++
//解决未定义pthread_rwlock_t的问题
#define _XOPEN_SOURCE 500       
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <bits/pthreadtypes.h>

//定义8个线程，其中3个写，5个读

#define MAX 50

pthread_rwlock_t rwlock;
int number = 0;

void* readNum(void* arg)
{
    for(int i = 0;i < MAX;i++)
    {
        pthread_rwlock_rdlock(&rwlock);
        printf("Thread read,ID = %ld,number = %d\n",pthread_self(),number);
        pthread_rwlock_unlock(&rwlock);
        usleep(rand()%5);
    }
    
}

void* writeNum(void* arg)
{
    for(int i = 0;i <MAX;i++)
    {
        pthread_rwlock_wrlock(&rwlock);
        number++;
        printf("Thread write,ID = %ld,number = %d\n",pthread_self(),number);
        pthread_rwlock_unlock(&rwlock);
        usleep(rand()%5);
    }
}

int main()
{
    pthread_t p1[3],p2[5];
    pthread_rwlock_init(&rwlock,NULL);
    for(int i = 0;i < 3;i++)
    {
        pthread_create(&p1[i],NULL,writeNum,NULL);
    }
    for(int i = 0;i < 5;i++)
    {
        pthread_create(&p2[i],NULL,readNum,NULL);
    }

    for(int i = 0;i < 3;i++)
        pthread_join(p1[i],NULL);
    for(int i = 0;i < 5;i++)
        pthread_join(p2[i],NULL);
    
    pthread_rwlock_destroy(&rwlock);
}
```

# 条件变量

互斥锁做线程同步， 条件变量负责阻塞线程

```C++
pthread_cond_t cond;
```

被条件变量阻塞的线程会被记录到cond变量里，以便解除阻塞时使用；

```C++
//线程阻塞函数，哪个线程调用该函数，哪个线程就会被阻塞
int pthread_cond_wait(pthread_cond_t* restrict cond,pthread_mutex_t* restrict mutex);
/*
在阻塞线程时，如果该线程已经上锁（pthread_mutex_lock），那么会把锁(mutex)打开，防止死锁；一般用于条件不满足时使用
在解除线程阻塞的时候，函数内部会给该线程上锁，继续向下访问临界区
*/
//唤醒线程函数
int pthread_cond_signal(pthread_cond_t* cond);
```

## 生产者消费者模型

```C++
//解决未定义pthread_rwlock_t的问题
#define _XOPEN_SOURCE 500       
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

pthread_mutex_t mutex;
pthread_cond_t cond;

struct Node
{
    int num;
    struct Node* next;
};
struct Node* head = NULL;

void* producer(void* arg)
{
    while (1)
    {
        pthread_mutex_lock(&mutex);
        //临界区
        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
        newNode->next = head;
        newNode->num = rand()%1000;
        head = newNode;
        printf("producer,ID = %ld,number = %d\n",pthread_self(),newNode->num);
        pthread_mutex_unlock(&mutex);
        pthread_cond_signal(&cond);

        usleep(rand()%5);
    }
    return NULL;
    
}

void* consumer(void* arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);
        while (head == NULL)
        {
            pthread_cond_wait(&cond,&mutex);
        }
        struct Node*pnode = head;
        head= pnode->next;
        printf("consumer,ID = %ld,number = %d\n",pthread_self(),pnode->num);
        free(pnode);
        
        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

int main()
{
    pthread_mutex_init(&mutex,NULL);
    pthread_cond_init(&cond,NULL);

    pthread_t p1[5],p2[5];
    for(int i = 0;i < 5;i++)
        pthread_create(&p1[i],NULL,producer,NULL);
    for (int i = 0; i < 5; i++)
        pthread_create(&p2[i],NULL,consumer,NULL);
    
    for(int i= 0;i <5;i++)
        pthread_join(p1[i],NULL);
    for (int i = 0; i < 5; i++)
        pthread_join(p2[i],NULL);
    

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
}
```

# 信号量

相对于条件变量来说更简洁

```C++
#include<semaphore.h>
sem_t sem;
int sem_init(sem_t* sem,int shared,unsigned int value);
/*
	shared：0代表线程同步，1代表进程同步
	value：初始化当前资源拥有的进程数 0阻塞
*/
int sem_destory(sem_t *sem);

sem_wait()自己的资源数-1,sem_post()别人的资源数+1
```

在与互斥锁一起使用时，应先判断有无信号量资源，再进行上锁

```C++
//解决未定义pthread_rwlock_t的问题
#define _XOPEN_SOURCE 500       
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include<semaphore.h>

pthread_mutex_t mutex;
sem_t semp,semc;

struct Node{
    int num;
    struct Node *next;
};
struct Node* head = NULL;

void* producer(void* arg)
{
    while (1)
    {
        sem_wait(&semp);
        pthread_mutex_lock(&mutex);
        struct Node* currNode = (struct Node*)malloc(sizeof(struct Node));
        currNode->num = rand()%1000;
        currNode->next = head;
        head = currNode;
        printf("producer,tid = %ld,number = %d\n",pthread_self(),currNode->num);
        pthread_mutex_unlock(&mutex);
        sem_post(&semc);
    }
    
    return NULL;
}
void* consumer(void* arg)
{
     while (1)
    {
        sem_wait(&semc);
        pthread_mutex_lock(&mutex);
        struct Node* pNode = head;
        printf("consumer,tid = %ld,number = %d\n",pthread_self(),pNode->num);
        head = pNode->next;
        free(pNode);
        pthread_mutex_unlock(&mutex);
        sem_post(&semp);
    }
    return NULL;
}

int main()
{
    pthread_mutex_init(&mutex,NULL);
    sem_init(&semp,0,5);
    sem_init(&semc,0,0);

    pthread_t p[5],c[5];

    for(int i =0;i < 5;i++)
        pthread_create(&p[i],NULL,producer,NULL);
    
    for(int i =0;i < 5;i++)
        pthread_create(&c[i],NULL,consumer,NULL);

    for(int i = 0;i < 5;i++)
        pthread_join(p[i],NULL);
    for(int i = 0;i < 5;i++)
        pthread_join(c[i],NULL);
    sem_destroy(&semp);
    sem_destroy(&semc);
    pthread_mutex_destroy(&mutex);
}
```

# 线程池（C语言版）

线程池的三个组成部分：

* 任务队列：线程使用者向任务队列中放入任务，生产者
* 工作线程：从任务队列中取出任务，消费者
* 管理者线程

```C++
//定义任务队列
typedef struct Task
{
    //处理任务的函数
    void (*function)(void* arg);
    //函数的参数
    void* arg;
}Task;
```



```C++
//线程池
struct ThreadPool
{
    Task*  taskQ;//任务队列
    int queueCapacity;//任务队列大小
    int queueSize;      // 当前任务个数
    int queueFront;//队列头，取出数据
    int queueRear;//队列尾部，放入数据

    pthread_t managerID;//存储管理者线程id
    pthread_t threadIDs;//存储工作线程;
    int maxNum,minNum;//工作线程的最大最小值
    int busyNum;//正在工作的线程数
    int liveNum;//存活的工作线程数
    int exitNum;//需要杀死的工作线程数

    pthread_mutex_t mutexPool;//对线程池上锁
    pthread_mutex_t mutexBusy;//对busyNum上锁
    pthread_cond_t notFull;//任务队列是否满了
    pthread_cond_t notEmpty;//任务队列是否空了

    int shutdown;//是否要销毁线程池
};
```

threadpool.h

```C++
#ifndef _THREADPOOL_H_
#define _THREADPOOL_H_
typedef struct ThreadPool ThreadPool;

ThreadPool* threadPoolCreate(int min,int max,int queueSize);
void* worker(void* arg);
void* manager(void* arg);
//线程退出函数
void threadExit(ThreadPool* pool);
//向线程池中添加任务
void threadPoolAdd(ThreadPool* pool,void (*func)(void* arg),void* );
//获取线程池中工作的线程个数
int threadPoolBusyNum(ThreadPool* pool);
//获取线程池中存活的线程个数
int threadPoolAliveNum(ThreadPool* pool);
//销毁线程池
int threadPoolDestroy(ThreadPool* pool);
#endif
```



threadpool.c

```C++
#include"threadpool.h"
#include<pthread.h>
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<unistd.h>

const int NUMBER = 2;

//定义任务队列
typedef struct Task
{
    //处理任务的函数
    void (*function)(void* arg);
    //函数的参数
    void* arg;
}Task;

//线程池
typedef struct ThreadPool
{
    Task*  taskQ;//任务队列
    int queueCapacity;//任务队列大小
    int queueSize;// 当前任务个数
    int queueFront;//队列头，取出数据
    int queueRear;//队列尾部，放入数据

    pthread_t managerID;//存储管理者线程id
    pthread_t* threadIDs;//存储工作线程;
    int maxNum,minNum;//工作线程的最大最小值
    int busyNum;//正在工作的线程数
    int liveNum;//存活的工作线程数
    int exitNum;//需要杀死的工作线程数

    pthread_mutex_t mutexPool;//对线程池上锁
    pthread_mutex_t mutexBusy;//对busyNum上锁
    pthread_cond_t notFull;//任务队列是否满了
    pthread_cond_t notEmpty;//任务队列是否空了

    int shutdown;//是否要销毁线程池
} ThreadPool;
ThreadPool* threadPoolCreate(int min,int max,int queueSize)
{
    ThreadPool* pool = (ThreadPool*)malloc(sizeof(struct ThreadPool));
        
    do
    {
        if(pool == NULL)
        {
            printf("failed to create pool...\n");
            break;
        }
        pool->threadIDs = (pthread_t *)malloc(sizeof(pthread_t)*max);
        if(pool->threadIDs == NULL)
        {
            printf("malloc threadIDs fail...\n");
            break;
        }
        memset(pool->threadIDs,0,sizeof(pthread_t)*max);//是0的线程即为可用线程
        pool->maxNum = max;
        pool->minNum = min;
        pool->busyNum = 0;
        pool->liveNum = min;
        pool->exitNum = 0;

    if(pthread_mutex_init(&pool->mutexPool,NULL) != 0 ||
        pthread_mutex_init(&pool->mutexBusy,NULL) != 0 ||
        pthread_cond_init(&pool->notEmpty,NULL) != 0 ||
        pthread_cond_init(&pool->notFull,NULL) != 0 
        )
    {
        printf("init mutex or condition fail...\n");
        break;
    }

    //任务队列
    pool->taskQ = (Task*)malloc(sizeof(struct Task)*queueSize);//忘记写queueSize
    pool->queueCapacity =  queueSize;
    pool->queueSize = 0;
    pool->queueFront = 0;
    pool->queueRear = 0;
    pool->shutdown = 0;

    //初始化线程
    pthread_create(&pool->managerID,NULL,manager,pool);
    for(int i = 0;i < min;i++)
     pthread_create(&pool->threadIDs[i],NULL,worker,pool);

    return pool;
    } while (0);
    
   // 释放资源
    if (pool && pool->threadIDs) free(pool->threadIDs);
    if (pool && pool->taskQ) free(pool->taskQ);
    if (pool) free(pool);

    return NULL;
    
}

//销毁线程
int threadPoolDestroy(ThreadPool* pool)
{
    if(pool == NULL) return -1;
    pool->shutdown = 1;
    //阻塞回收管理者线程
    pthread_join(pool->managerID,NULL);
    //阻塞唤醒消费者线程
    for(int i =0;i < pool->liveNum;i++)
    {
        pthread_cond_signal(&pool->notEmpty);
    }

    if(pool->taskQ)
        free(pool->taskQ);
    if(pool->threadIDs)
        free(pool->threadIDs);

    pthread_mutex_destroy(&pool->mutexPool);
    pthread_mutex_destroy(&pool->mutexBusy);
    pthread_cond_destroy(&pool->notEmpty);
    pthread_cond_destroy(&pool->notFull);

    free(pool);
    pool = NULL;

    return 0;

}

//向线程池中添加任务
void threadPoolAdd(ThreadPool* pool,void (*func)(void*),void* arg)
{
    pthread_mutex_lock(&pool->mutexPool);
    //线程池开启并且任务队列满了
    while (pool->queueSize == pool->queueCapacity && !pool->shutdown)
    {
        pthread_cond_wait(&pool->notFull,&pool->mutexPool);
    }

    if(pool->shutdown)
    {
        pthread_mutex_unlock(&pool->mutexPool);
        return;
    }

    pool->taskQ[pool->queueRear].function = func;
    pool->taskQ[pool->queueRear].arg = arg;
    pool->queueRear = (pool->queueRear + 1) % pool->queueCapacity;  
    pool->queueSize++;
    
    pthread_cond_signal(&pool->notEmpty);
    pthread_mutex_unlock(&pool->mutexPool);
}

//获取线程池中工作的线程个数
int threadPoolBusyNum(ThreadPool* pool)
{
    pthread_mutex_lock(&pool->mutexBusy);
    int busyNum = pool->busyNum;
    pthread_mutex_unlock(&pool->mutexBusy);
    return busyNum;
}
//获取线程池中存活的线程个数
int threadPoolAliveNum(ThreadPool* pool)
{
    pthread_mutex_lock(&pool->mutexPool);
    int aliveNum = pool->liveNum;
    pthread_mutex_unlock(&pool->mutexPool);
    return aliveNum;
}


void* worker(void* arg)
{
    //取出参数
    ThreadPool* pool= (ThreadPool*)arg;

    while(1)
    {
        //对线程池上锁
        pthread_mutex_lock(&pool->mutexPool);
        //当任务队列为空时，阻塞队列
        while(!pool->shutdown && pool->queueSize == 0)
        {
            pthread_cond_wait(&pool->notEmpty,&pool->mutexPool);

            //判断是否要销毁线程，如果线程池中所有任务都有对应线程，那么queueSize会减到0
            if(pool->exitNum > 0)
            {
                pool->exitNum--;
                if(pool->liveNum >pool->minNum)
                {
                    pool->liveNum--;
                    pthread_mutex_unlock(&pool->mutexPool);
                    threadExit(pool);
                }
            }
        }
        
        //判断线程池是否关闭
        if(pool->shutdown)
        {
            pthread_mutex_unlock(&pool->mutexPool);
            threadExit(pool);
        }

        //取出任务
        Task task;
        task.function = pool->taskQ[pool->queueFront].function;
        task.arg = pool->taskQ[pool->queueFront].arg;

        //移动任务节点
        pool->queueFront = (pool->queueFront + 1) % pool->queueCapacity;
        pool->queueSize--;
        pthread_cond_signal(&pool->notFull);//唤醒生产者线程
        pthread_mutex_unlock(&pool->mutexPool);

        printf("thread : %ld start working ...\n",pthread_self());
        pthread_mutex_lock(&pool->mutexBusy);
        pool->busyNum++;
        pthread_mutex_unlock(&pool->mutexBusy);       
        task.function(task.arg);
        free(task.arg);
        task.arg = NULL;

        printf("thread : %ld end working ...\n",pthread_self());
        pthread_mutex_lock(&pool->mutexBusy);
        pool->busyNum--;
        pthread_mutex_unlock(&pool->mutexBusy);       
    }
    return NULL;
}

void* manager(void* arg)
{
    ThreadPool* pool = (ThreadPool*)arg;
    while (!pool->shutdown)
    {
        sleep(3);

        //取出与任务数量有关的函数
        pthread_mutex_lock(&pool->mutexPool);
        int queueSize = pool->queueSize;
        int liveNum =pool->liveNum;
        pthread_mutex_unlock(&pool->mutexPool);

        pthread_mutex_lock(&pool->mutexBusy);
        int busyNum = pool->busyNum;
        pthread_mutex_unlock(&pool->mutexBusy);

        /*
        添加线程，规则：任务数量大于存活数量且存活线程数小于最大值,一次最多加两个
        */
       if(liveNum < queueSize && liveNum < pool->maxNum)
       {
            pthread_mutex_lock(&pool->mutexPool);
            int counter = 0;
            for(int i = 0; i < pool->maxNum && counter < NUMBER && 
            pool->liveNum < pool->maxNum;i++ )
            {
                if(pool->threadIDs[i] == 0)
                {
                    pthread_create(&pool->threadIDs[i],NULL,worker,pool);
                    pool->liveNum++;
                    counter++;
                }
            }
            pthread_mutex_unlock(&pool->mutexPool);
       }

       //销毁线程，规则：忙的线程*2 ＜ 存货线程 且 存活线程大于最小值
       if(busyNum*2 < liveNum && liveNum > pool->minNum)
       {
            pthread_mutex_lock(&pool->mutexPool);
            pool->exitNum = NUMBER;
            pthread_mutex_unlock(&pool->mutexPool);

            for(int i = 0;i < NUMBER;i++)
            {
                pthread_cond_signal(&pool->notEmpty);
            }
       }

    }
    return NULL;
}
//线程退出函数
void threadExit(ThreadPool* pool)
{
    pthread_t tid = pthread_self();
    for(int i = 0;i < pool->maxNum;i++)
    {
        if(pool->threadIDs[i] == tid)
        {
             pool->threadIDs[i] = 0;
            printf("threadExit() called, %ld exiting...\n", tid);
            break;
        }
    }
    pthread_exit(NULL);
}
```



main.c

```C++
#include<stdio.h>
#include"threadpool.h"
#include<pthread.h>
#include<unistd.h>
#include<stdlib.h>

void taskFunc(void* arg)
{
    int num = *(int*)arg;
    printf("thread %ld is working, number = %d\n",
        pthread_self(), num);
    sleep(1);
}

int main()
{
    // 创建线程池
    ThreadPool* pool = threadPoolCreate(3, 10, 100);
    for (int i = 0; i < 100; ++i)
    {
        int* num = (int*)malloc(sizeof(int));
        *num = i + 100;
        threadPoolAdd(pool, taskFunc, num);
    }

    sleep(30);

    threadPoolDestroy(pool);
    return 0;
}
```

# 线程池（C++版）

TaskQueue.h

```C++
#pragma once
#include<pthread.h>
#include<queue> 
#include<iostream>
#include<pthread.h>


using callback = void(*)(void*);
struct Task
{
    Task(){};
    Task(callback f,void* arg)
    {
        func = f;
        this->arg = arg;
    }
    callback func;
    void* arg;
} 

;

class TaskQueue
{
    public:
        TaskQueue();
        ~TaskQueue();

        //添加任务
        void addTask(Task task);
        void addTask(callback f,void* arg);
        //取出任务
        Task takeTask();
        //获取任务的数量
        inline int taskNumber()
        {
            return m_queue.size();
        }


    private:
        std::queue<Task> m_queue;
        pthread_mutex_t m_mutex;
};

```

TaskQueue.cpp

```C++
#include"TaskQueue.h"

TaskQueue::TaskQueue()
{
    pthread_mutex_init(&m_mutex,NULL);
}
TaskQueue::~TaskQueue()
{
    pthread_mutex_destroy(&m_mutex);
}

//添加任务
void TaskQueue::addTask(Task task)
{
    pthread_mutex_lock(&m_mutex);
    m_queue.push(task);
    pthread_mutex_unlock(&m_mutex);
}
void TaskQueue::addTask(callback f,void* arg)
{
    pthread_mutex_lock(&m_mutex);
    m_queue.push(Task(f,arg));
    pthread_mutex_unlock(&m_mutex);
}

Task TaskQueue::takeTask()
{
    Task t;
    pthread_mutex_lock(&m_mutex);
    if(!m_queue.empty())
    {
        t = m_queue.front();
        m_queue.pop();
    }
    pthread_mutex_unlock(&m_mutex);

    return t;
}
```

ThreadPool.h

```C++
#pragma once
#include"TaskQueue.h"

class ThreadPool
{
    private:
        TaskQueue*  m_taskQ;//任务队列

        pthread_t managerID;//存储管理者线程id
        pthread_t* threadIDs;//存储工作线程;
        int maxNum,minNum;//工作线程的最大最小值
        int busyNum;//正在工作的线程数
        int liveNum;//存活的工作线程数
        int exitNum;//需要杀死的工作线程数

        pthread_mutex_t mutexPool;//对busyNum上锁
        pthread_cond_t notEmpty;//任务队列是否空了

        bool shutdown;//是否要销毁线程池
    private:
        static void* worker(void* arg);//静态方法中不能访问非静态成员
        static void* manager(void* arg);
        //线程退出函数
        void threadExit();
    public:
        ThreadPool(int min,int max);
        ~ThreadPool();
        
        //向线程池中添加任务
        void addTask(Task task);
        //获取线程池中工作的线程个数
        int getBusyNum();
        //获取线程池中存活的线程个数
        int getAliveNum();
        static const int NUMBER = 2;
};
```

ThreadPool.cpp

```C++
#include<iostream>
#include"ThreadPool.h"
#include<string.h>
#include<string>
#include <unistd.h>

using namespace std;

ThreadPool::ThreadPool(int min,int max)
{
        
    do
    {
        m_taskQ = new TaskQueue;
        if(m_taskQ == nullptr)
            cout<<"failed to init taskqueue..."<<endl;
        threadIDs = new pthread_t[max];
        if(threadIDs == nullptr)
        {
            cout<<"malloc threadIDs fail...\n";
            break;
        }
        memset(threadIDs,0,sizeof(pthread_t)*max);//是0的线程即为可用线程
        maxNum = max;
        minNum = min;
        busyNum = 0;
        liveNum = min;
        exitNum = 0;

    if(
        pthread_mutex_init(&mutexPool,NULL) != 0 ||
        pthread_cond_init(&notEmpty,NULL) != 0
        )
    {
        cout<<"init mutex or condition fail...\n";
        break;
    }


    shutdown = false;

    //初始化线程
    pthread_create(&managerID,NULL,manager,this);
    for(int i = 0;i < min;i++)
     pthread_create(&threadIDs[i],NULL,worker,this);

    return;
    } while (0);
    
}

//销毁线程
ThreadPool::~ThreadPool()
{
    shutdown = true;
    //阻塞回收管理者线程
    pthread_join(managerID,NULL);
    //阻塞唤醒消费者线程
    for(int i =0;i <liveNum;i++)
    {
        pthread_cond_signal(&notEmpty);
    }

    if(m_taskQ)
        delete m_taskQ;
    if(threadIDs)
        delete threadIDs;

    pthread_mutex_destroy(&mutexPool);
    pthread_cond_destroy(&notEmpty);
}

//向线程池中添加任务
void ThreadPool::addTask(Task task)
{
    if(shutdown)
    {
        return;
    }

    m_taskQ->addTask(task);
    
    pthread_cond_signal(&notEmpty);
}

//获取线程池中工作的线程个数
int ThreadPool::getBusyNum()
{
    pthread_mutex_lock(&mutexPool);
    int busyNum = this->busyNum;
    pthread_mutex_unlock(&mutexPool);
    return busyNum;
}
//获取线程池中存活的线程个数
int ThreadPool::getAliveNum()
{
    pthread_mutex_lock(&mutexPool);
    int aliveNum = this->liveNum;
    pthread_mutex_unlock(&mutexPool);
    return aliveNum;
}


void* ThreadPool::worker(void* arg)
{
    //取出参数
    ThreadPool* pool= (ThreadPool*)arg;

    while(true)
    {
        //对线程池上锁
        pthread_mutex_lock(&pool->mutexPool);
        //当任务队列为空时，阻塞队列
        while(!pool->shutdown && pool->m_taskQ->taskNumber()== 0)
        {
            pthread_cond_wait(&pool->notEmpty,&pool->mutexPool);

            //判断是否要销毁线程，如果线程池中所有任务都有对应线程，那么queueSize会减到0
            if(pool->exitNum > 0)
            {
                pool->exitNum--;
                if(pool->liveNum >pool->minNum)
                {
                    pool->liveNum--;
                    pthread_mutex_unlock(&pool->mutexPool);
                    pool->threadExit();
                }
            }
        }
        
        //判断线程池是否关闭
        if(pool->shutdown)
        {
            pthread_mutex_unlock(&pool->mutexPool);
            pool->threadExit();
        }

        //取出任务
        Task task = pool->m_taskQ->takeTask();
        pool->busyNum++;
        pthread_mutex_unlock(&pool->mutexPool);

        printf("thread : %ld start working ...\n",pthread_self());    
        task.func(task.arg);
        delete task.arg;
        task.arg = nullptr;

        printf("thread : %ld end working ...\n",pthread_self());
        pthread_mutex_lock(&pool->mutexPool);
        pool->busyNum--;
        pthread_mutex_unlock(&pool->mutexPool);       
    }
    return nullptr;
}

void* ThreadPool::manager(void* arg)
{
    ThreadPool* pool = (ThreadPool*)arg;
    while (!pool->shutdown)
    {
        sleep(3);

        //取出与任务数量有关的函数
        pthread_mutex_lock(&pool->mutexPool);
        int queueSize = pool->m_taskQ->taskNumber();
        int liveNum =pool->liveNum;
        int busyNum = pool->busyNum;
        pthread_mutex_unlock(&pool->mutexPool);

        /*
        添加线程，规则：任务数量大于存活数量且存活线程数小于最大值,一次最多加两个
        */
       if(liveNum < queueSize && liveNum < pool->maxNum)
       {
            pthread_mutex_lock(&pool->mutexPool);
            int counter = 0;
            for(int i = 0; i < pool->maxNum && counter < NUMBER && 
            pool->liveNum < pool->maxNum;i++ )
            {
                if(pool->threadIDs[i] == 0)
                {
                    pthread_create(&pool->threadIDs[i],NULL,worker,pool);
                    pool->liveNum++;
                    counter++;
                }
            }
            pthread_mutex_unlock(&pool->mutexPool);
       }

       //销毁线程，规则：忙的线程*2 ＜ 存货线程 且 存活线程大于最小值
       if(busyNum*2 < liveNum && liveNum > pool->minNum)
       {
            pthread_mutex_lock(&pool->mutexPool);
            pool->exitNum = NUMBER;
            pthread_mutex_unlock(&pool->mutexPool);

            for(int i = 0;i < NUMBER;i++)
            {
                pthread_cond_signal(&pool->notEmpty);
            }
       }

    }
    return nullptr;
}
//线程退出函数
void ThreadPool::threadExit()
{
    pthread_t tid = pthread_self();
    for(int i = 0;i < maxNum;i++)
    {
        if(threadIDs[i] == tid)
        {
            threadIDs[i] = 0;
            printf("threadExit() called, %ld exiting...\n", tid);
            break;
        }
    }
    pthread_exit(NULL);
}
```

main.cpp

```C++
#include<unistd.h>
#include"ThreadPool.h"
#include"TaskQueue.h"
#include<iostream>

void taskFunc(void* arg)
{
    int num = *(int*)arg;
    std::cout<<"thread : "<<pthread_self()<<" is working , number =  "<<num<<std::endl;
}

int main()
{
    ThreadPool pool(3,10);
    for(int i = 0;i < 100;i++)
    {
        int *num = new int;
        *num = i+100;
        pool.addTask(Task(taskFunc,num));
    }
    sleep(30);
}
```

# C++11多线程

```c++
#include<iostream>
#include<thread>

void hello()
{
    std::cout<<"hello,current thread;\n";
}

int main()
{
    std::thread t(hello);
    t.join();
}
```

## 命名空间this_thread

std::this_thread

get_id()

```c++
std::this_thread::id get_id();
```

```C++
#include<iostream>
#include<thread>

int main()
{
	std::cout<< std::this_thread::get_id()<<std::endl;
}
```

sleep_for()/sleep_until()



yield()//主动放弃当前的cpu时间片



bool joinable() 子线程创建之后调用回调函数，父子线程才会建立连接；



## 类的成员函数作为子线程的任务函数

普通成员函数和静态成员函数都可以

```C++
```

## call_once()函数

* 能够被多个数据访问并且保证数据安全性
* 被call_once函数修饰的函数只能被调用一次

