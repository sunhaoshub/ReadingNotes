智能指针管理原始指针；

管理堆或自由存储区时，可以使用智能指针；

通过重载的运算符和析构函数确保动态分配的数据能及时销毁，从而提供了更多有用的功能；

智能指针重载了解引用运算符和成员选择运算符；

智能指针的分类其实就是内存资源管理策略的分类，可以分为如下几类：

* 深复制
* 写时复制（Copy on Write，COW）
* 引用计数
* 引用链接
* 破坏性复制

引入头文件<memory\>

* std::shared_ptr，允许多个shared_ptr指向同一块内存，当某个shared_ptr析构时，引用计数就减1，当最后一个shared_ptr析构时，会自动释放内存；
* std::unique_ptr，引用计数只能为1；
* std::weak_ptr，监视shared_ptr

# shared_ptr

## 初始化方式

1、通过构造函数初始化

```
std::shared_ptr<T> ptr(堆内存);
```

```C++
#include<iostream>
#include<memory>

using namespace std;
int main()
{
	shared_ptr<int> p1(new int(100));
	cout << "p1的引用计数是：" << p1.use_count()<<endl;
	shared_ptr<int> p2;
	cout << "p2的引用计数是：" << p2.use_count() << endl;
	shared_ptr<int> p3(nullptr);
	cout << "p3的引用计数是：" << p3.use_count() << endl;
}
```

2、通过拷贝构造函数和移动构造函数初始化

```C++
通过移动构造函数只是转移内存的所有权，不会增加引用计数
```

3、通过std::make_shared方法进行初始化

```C++
#include<iostream>
#include<memory>

using namespace std;

class Test
{
public:
    Test()
    {
        cout << "construct Test..." << endl;
    }
    Test(int x)
    {
        cout << "construct Test, x = " << x << endl;
    }
    Test(string str)
    {
        cout << "construct Test, str = " << str << endl;
    }
    ~Test()
    {
        cout << "destruct Test ..." << endl;
    }
};

int main()
{
	shared_ptr<Test> p1 = make_shared<Test>(8);
    cout << "p1的引用计数是：" << p1.use_count() << endl;
	shared_ptr<Test> p2 = make_shared<Test>("Hello,World");
    cout << "p2的引用计数是：" << p2.use_count() << endl;
}
```



4、通过std::shared_ptr::reset()方法进行初始化

可以让当前智能指针从管理A内存切换到管理B内存



## 获取引用计数

use_count()方法

## 获取原始指针

get()方法

可能会导致悬挂指针问题

```C++
#include<iostream>
#include<memory>

using namespace std;

int main()
{
	shared_ptr<int> p1 = make_shared<int>(8);
    int* ptr2 = p1.get();
}
```

## 指定删除器

智能指针管理数组类型时必须指定删除器函数，其他类型不需要;

默认删除器函数：std::default_delete\<T>()

```c++
#include<iostream>
#include<memory>

using namespace std;

class Test
{
public:
    Test()
    {
        cout << "construct Test..." << endl;
    }
    Test(int x)
    {
        cout << "construct Test, x = " << x << endl;
    }
    Test(string str)
    {
        cout << "construct Test, str = " << str << endl;
    }
    ~Test()
    {
        cout << "destruct Test ..." << endl;
    }
};

int main()
{
    /*shared_ptr<Test> p1(new Test[5], [](Test* t) {
        delete[]t;
        });*/
    shared_ptr<Test> p1(new Test[5], default_delete<Test[]>());
    
}
```
