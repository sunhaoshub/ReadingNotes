智能指针管理原始指针；

管理堆或自由存储区时，可以使用智能指针；

通过重载的运算符和析构函数确保动态分配的数据能及时销毁，从而提供了更多有用的功能；

智能指针重载了解引用运算符和成员选择运算符；

智能指针的分类其实就是内存资源管理策略的分类，可以分为如下几类：

* 深复制
* 写时复制（Copy on Write，COW）
* 引用计数
* 引用链接
* 破坏性复制

引入头文件<memory\>

* std::shared_ptr，允许多个shared_ptr指向同一块内存，当某个shared_ptr析构时，引用计数就减1，当最后一个shared_ptr析构时，会自动释放内存；
* std::unique_ptr，引用计数只能为1；
* std::weak_ptr，监视shared_ptr

# shared_ptr

## 初始化方式

1、通过构造函数初始化

```
std::shared_ptr<T> ptr(堆内存);
```

```C++
#include<iostream>
#include<memory>

using namespace std;
int main()
{
	shared_ptr<int> p1(new int(100));
	cout << "p1的引用计数是：" << p1.use_count()<<endl;
	shared_ptr<int> p2;
	cout << "p2的引用计数是：" << p2.use_count() << endl;
	shared_ptr<int> p3(nullptr);
	cout << "p3的引用计数是：" << p3.use_count() << endl;
}
```

2、通过拷贝构造函数和移动构造函数初始化

```C++
通过移动构造函数只是转移内存的所有权，不会增加引用计数
```

3、通过std::make_shared方法进行初始化

```C++
#include<iostream>
#include<memory>

using namespace std;

class Test
{
public:
    Test()
    {
        cout << "construct Test..." << endl;
    }
    Test(int x)
    {
        cout << "construct Test, x = " << x << endl;
    }
    Test(string str)
    {
        cout << "construct Test, str = " << str << endl;
    }
    ~Test()
    {
        cout << "destruct Test ..." << endl;
    }
};

int main()
{
	shared_ptr<Test> p1 = make_shared<Test>(8);
    cout << "p1的引用计数是：" << p1.use_count() << endl;
	shared_ptr<Test> p2 = make_shared<Test>("Hello,World");
    cout << "p2的引用计数是：" << p2.use_count() << endl;
}
```



4、通过std::shared_ptr::reset()方法进行初始化

可以让当前智能指针从管理A内存切换到管理B内存



## 获取引用计数

use_count()方法

## 获取原始指针

get()方法

可能会导致悬挂指针问题

```C++
#include<iostream>
#include<memory>

using namespace std;

int main()
{
	shared_ptr<int> p1 = make_shared<int>(8);
    int* ptr2 = p1.get();
}
```

## 指定删除器

智能指针管理数组类型时必须指定删除器函数，其他类型不需要;

默认删除器函数：std::default_delete\<T>()

```c++
#include<iostream>
#include<memory>

using namespace std;

class Test
{
public:
    Test()
    {
        cout << "construct Test..." << endl;
    }
    Test(int x)
    {
        cout << "construct Test, x = " << x << endl;
    }
    Test(string str)
    {
        cout << "construct Test, str = " << str << endl;
    }
    ~Test()
    {
        cout << "destruct Test ..." << endl;
    }
};

int main()
{
    /*shared_ptr<Test> p1(new Test[5], [](Test* t) {
        delete[]t;
        });*/
    shared_ptr<Test> p1(new Test[5], default_delete<Test[]>());
    
}
```

# weak_ptr

* 辅助shared_ptr，不占用或减少引用计数，只是一个旁观者
* 可以通过shared_ptr来构造初始化

* 通过use_count()函数获取正在观测的引用计数

```c++
#include<iostream>
#include<memory>
using namespace std;
int main()
{
	shared_ptr<int> sp(new int(0));
	weak_ptr<int> wp1;
	weak_ptr<int> wp2 = wp1;
	weak_ptr<int> wp3(wp1);
	weak_ptr<int> wp4(sp);
	weak_ptr<int> wp5 = sp;

	cout << "wp1.use_count() = " << wp1.use_count() << endl;
	cout << "wp2.use_count() = " << wp2.use_count() << endl;
	cout << "wp3.use_count() = " << wp3.use_count() << endl;
	cout << "wp4.use_count() = " << wp4.use_count() << endl;
	cout << "wp5.use_count() = " << wp5.use_count() << endl;
}
```

*  通过expired()函数来确定观察的资源是否被释放，bool类型
* 通过lock()函数来获取监测的shared_ptr类型,赋值后相当于多增加了一个引用计数
* 通过reset()函数来清空weak_ptr，即不再监视任何对象

## 处理返回this

```c++
#include<iostream>
#include<memory>
using namespace std;

class Test
{
public:
	shared_ptr<Test> getSharedPtr()
	{
		return shared_ptr<Test>(this);
	}
	~Test()
	{
		cout << "destructor()...." << endl;
	}
};

int main()
{
	shared_ptr<Test> ptr1(new Test);
	cout << "ptr1.use_count() = " << ptr1.use_count() << endl;
	shared_ptr<Test> ptr2 = ptr1->getSharedPtr();
	cout << "ptr1.use_count() = " << ptr1.use_count() << endl;
	return 0;
}
```

两次输出都为1，因为ptr2没有通过ptr1来构造，两个智能指针之间没有关系

解决方法：

令需要返回shared_ptr的类继承模板类enable_shared_from_this\<T>，并且将返回this换成shared_from_this()，该函数使用weak_ptr来监视内存，并使用lock返回shared_ptr对象

```C++
#include<iostream>
#include<memory>
using namespace std;

class Test:public enable_shared_from_this<Test>
{
public:
	shared_ptr<Test> getSharedPtr()
	{
		return shared_from_this();
	}
	~Test()
	{
		cout << "destructor()...." << endl;
	}
};

int main()
{
	shared_ptr<Test> ptr1(new Test);
	cout << "ptr1.use_count() = " << ptr1.use_count() << endl;
	shared_ptr<Test> ptr2 = ptr1->getSharedPtr();
	cout << "ptr1.use_count() = " << ptr1.use_count() << endl;
	return 0;
}
```



## 解决循环引用

