# 类和对象

类中的成员变量只有当实例化一个对象之后才会分配内存并变得有效，在此之前，这些成员变量并不存在；

## 句点运算符和指针运算符

句点运算符(.)用于对象访问类成员

如果声明了一个指向类的指针，则需要用指针运算符(->)访问，或者解引用(*)

```C++
class Human
{
	public:
    	intruduce();
};
int main()
{
    Human human;
    human.introduce();
    Human* man = new Human();
    man->introduce();
    (*man).introduce();
}
```

# 关键字public和private

​	private表示只能在类的内部或者友元访问；

​	通过private实现了数据抽象，程序员可以决定哪些属性只能让类内访问，类外（除友元）任何人都不能访问；

# 构造函数

​	可以在类内声明，类外定义，类外定义需要用到作用域解析运算符(::)

```c++
class Human
{
    Human();
};
Human::Human()
{
    std::cout<<"This is constructor function;"<<std::endl;
}
```

​	构造函数总是在类初始化时被创建，所以为类成员变量初始化（如整型变量、指针等）创造了理想时机;

​	当类中有重载构造函数后，编译器不会生成默认构造函数

```c++
#include<iostream>

class Human {
public:
	Human(char a)
	{
		std::cout << "This is default constructor" << std::endl;
	}
	Human(int a)
	{
		std::cout << "This is overload constructor" << std::endl;
	}
};

int main()
{	
	Human human;
}
```

![image-20231114211327807](C:\Users\sunha\AppData\Roaming\Typora\typora-user-images\image-20231114211327807.png)

## 带默认值的构造函数

​	默认构造函数是调用时可不提供参数（有默认参数）的构造函数，而不是不接受任何参数的构造函数

## 初始化列表

​	对于普通变量来说，在函数体内初始化还是使用初始化列表没有区别，但是对于类类型，使用初始化列表可以避免多次初始化和调用默认构造函数；??

```c++
#include<iostream>

class A
{
public:
	A()
	{
		std::cout << "This is A default constructor" << std::endl;
	}
	A(int a)
	{
		std::cout << "This is A(" << a << ") constructor" << std::endl;
	}
};

class B
{
public:
	A a1, a2;
	B():a1(1)
	{
		a2 = A(2);
	}
};

int main()
{	
	B b;
}

```

## 如何及何时使用析构函数

​	每当对象不在作用域或者通过delete被删除进而销毁时，都将调用析构函数。这使得析构函数成为重置变量以及释放动态分配的内存和其他资源的理想场所；

​	一个封装字符缓冲区并通过析构函数释放的类

```c++
#include<iostream>
#include<string.h>
#pragma warning(disable:4996)

class MyString
{
private:
	char* buffer;
public:
	MyString(const char* initString)
	{
		if (initString != NULL)
		{
			buffer = new char[strlen(initString) + 1];
			strcpy(buffer, initString);
		}
		else
			buffer = NULL;
	}
	~MyString()
	{
		std::cout << "Invoking destructor, clearing up" << std::endl;
		if(buffer != NULL)
			delete[] buffer;
	}
	int GetLen()
	{
		return strlen(buffer);
	}
	const char* GetString()
	{
	 return buffer;
	}
};

int main()
{
	MyString sayHello("Hello from String Class");
	std::cout << "String buffer in sayHello is " << sayHello.GetLen() << " characters long" << std::endl;
	std::cout << "Buffer contains: " << sayHello.GetString() << std::endl;
}
```

# 拷贝构造函数

​	复制MyString类的对象时，将复制指针成员，但不复制指针指向的缓冲区，导致两个指针指向同一块动态分配的内存。销毁一个对象时，析构函数会释放这个内存块，导致另一个对象存储的指针拷贝无效，这种复制被称为浅拷贝；

```c++
#include<iostream>
#include<string.h>
#pragma warning(disable:4996)

class MyString
{
private:
	char* buffer;
public:
	MyString(const char* initString)
	{
		if (initString != NULL)
		{
			buffer = new char[strlen(initString) + 1];
			strcpy(buffer, initString);
		}
		else
			buffer = NULL;
	}
	~MyString()
	{
		std::cout << "Invoking destructor, clearing up" << std::endl;
		if(buffer != NULL)
			delete[] buffer;
	}
	int GetLen()
	{
		return strlen(buffer);
	}
	const char* GetString()
	{
	 return buffer;
	}
};

void UseMyString(MyString str)
{
	std::cout << "String buffer in sayHello is " << str.GetLen() << " characters long" << std::endl;
	std::cout << "Buffer contains: " << str.GetString() << std::endl;
}

int main()
{
	MyString sayHello("Hello from String Class");
	UseMyString(sayHello);
}
```

HEAP[shStudy.exe]: Invalid address specified to RtlValidateHeap( 01690000, 016A2500 )

对于整型、字符和原始指针等 POD 数据，编译器执行二进制复制，而二进制复制不复制内存空间；

## 使用拷贝构造函数确保深拷贝

​	它是一个重载的构造函数，每当对象被复制时，编译器将调用拷贝构造函数；

​	拷贝构造函数被调用的场景

```
1.使用一个对象初始化另一个对象
2.以值的方式传递对象给函数
3.从函数返回对象
4.初始化容器元素
```

```C++
#include<iostream>
#include<string.h>
#pragma warning(disable:4996)

class MyString
{
private:
	char* buffer;
public:
	MyString(const char* initString)
	{
		if (initString != NULL)
		{
			buffer = new char[strlen(initString) + 1];
			strcpy(buffer, initString);
			std::cout << "buffer points to: 0x"  <<(unsigned int*)buffer <<std::endl;
		}
		else
			buffer = NULL;
	}
	MyString(const MyString& copySource)
	{
		buffer = NULL;
		buffer = new char[strlen(copySource.buffer) + 1];
		strcpy(buffer, copySource.buffer);
		std::cout << "Copy constructor: copying from MyString" << std::endl;
		std::cout << "buffer points to: 0x" << (unsigned int*)buffer << std::endl;
	}
	~MyString()
	{
		std::cout << "Invoking destructor, clearing up" << std::endl;
		if(buffer != NULL)
			delete[] buffer;
	}
	int GetLen()
	{
		return strlen(buffer);
	}
	const char* GetString()
	{
	 return buffer;
	}
};

void UseMyString(MyString str)
{
	std::cout << "String buffer in sayHello is " << str.GetLen() << " characters long" << std::endl;
	std::cout << "Buffer contains: " << str.GetString() << std::endl;
}

int main()
{
	MyString sayHello("Hello from String Class");
	UseMyString(sayHello);
}
```

