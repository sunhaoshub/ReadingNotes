# 虚拟地址空间

区分虚拟内存和虚拟地址空间

系统中所有进程的内核区都被映射到同一块物理地址空间

![img](https://subingwen.cn/linux/file-descriptor/image-20210130093015907.png)

* 保留区：空白区，null指针指向的地方
* .text区：只读代码段
* .data区：保存已初始化且不为0的全局变量和静态变量，可读可写
* .bss段：保存未初始化以及初始为0的全局变量和静态变量，操作系统会将这些未初始化变量初始化为0
* 内存映射区：加载磁盘文件，或者加载程序运作过程中需要调用的动态库

# 文件描述符

Linux中万物皆文件

默认分配的文件描述符：

STDIN_FILENO,STDOUT_FILENO,STDERR_FILENO，对应的宏默认是0，1，2

默认分配的文件描述符可以通过close()关掉

# Linux文件IO

系统函数不是内核函数，充当用户和内核函数之间的接口

# 管道

* 分为有名管道和匿名管道，匿名管道只适用于有亲缘关系的进程
* 匿名管道的本质是内核缓冲区
* 有名管道的本质是文件系统

## 匿名管道pipe

匿名管道创建函数:

```C++
int pipe(int fd[2]);//成功返回0，失败返回-1,这两个文件描述符都指向同一块内存缓冲区
```

```C++
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
    int fd[2];//0 读（子进程） 1 写（父进程）
    int ret = pipe(fd);
    if(fd < 0)
    {
        perror("failed to init pipe...");
        exit(1);
    }
    pid_t pid;
    pid = fork();
    if(pid == -1)
    {
        perror("failed to fork...");
    }
    else if(pid == 0)//子进程 读
    {
        close(fd[1]);
        char buf[1024];
        printf("child_pid = %d",getpid());
        int ret = read(fd[0],buf,sizeof(buf));
        write(STDOUT_FILENO,buf,ret);
    }
    else if(pid > 0)//父进程 写
    {
        close(fd[0]);
        printf("parent_pid = %d",getpid());
        write(fd[1],"Hello,Pipe\n",11);
        wait(NULL);
    }
}
```





匿名管道的缺点：

* 数据区大小只有4K
* 数据不能重复读
* 半双工

## 有名管道fifo

