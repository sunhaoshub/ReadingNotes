# UML类图的画法

unified modeling language

设计程序之前画

![image-20240203164356236](C:\Users\sunha\Desktop\book\ReadingNotes\设计模式.assets\image-20240203164356236.png)

上层是类名，中间层是类的成员变量，下层是类的方法

* 可见性：+表示public，-表示private，#表示protected，_(下划线)表示静态

* 属性的表示方式：【可见性】【变量名】:【类型】(=【默认值】，括号内容可不写)
* 方法的表示方式：【可见性】【方法名】(【参数列表】):【返回类型】

纯虚函数，类名用斜体

# 类与类之间的关系（5）

## 继承关系

用一条空心箭头实线链接两个类，箭头方向指向父类

## 关联关系

一个类是另一个类的**成员变量**

单向关联、双向关联、自关联

带箭头或不带箭头的实线连接（箭头有无取决于画图软件）

自关联自己指向自己

## 聚合关系

整体被析构了，成员没有被析构；

例子：汽车与轮胎、引擎、车灯

用空心菱形直线表示，菱形指向整体；

### 代码实现聚合关系

成员对象以构造方法、Setter方法的方式注入到整体对象中，因为成员对象可以脱离整体对象独立存在

## 组合关系

当整体被析构时，部分也随之析构

带实心的菱形

## 依赖关系

1.将一个类的对象作为另一个类中**方法的参数**

2.在一个类中的方法将另一个类的对象作为**局部变量**

3.在一个类中调用另一个类的**静态方法**



用带箭头的虚线表示



依赖指向被依赖 

## 关系强弱

继承＞组合＞聚合＞关联＞依赖

# 设计模式的三个基本原则 

## 单一原则

将单一事物抽象成类

## 开放封闭原则

在封装旧的类的时候预留一些接口

多态

## 依赖倒转原则

1.高层模块不应该依赖于低层模块，两个都应该依赖于抽象

2.抽象不应该依赖于细节，细节应该依赖抽象

解释：

* 高层模块：可以理解为上层应用，就是业务层的实现
* 低层模块：底层接口，如封装好的API，动态库等
* 抽象：抽象类或接口，C++中只有抽象类

# 单例模式和任务队列

只能有一个实例对象

队列中存储任务函数（的地址）或可调用对象

典型的应用就是任务队列

用单例来代替全局变量，全局变量会破坏类的封装（全局变量可以随意被修改）

涉及到一个类多个对象的函数有：

* 构造函数
* 拷贝构造函数
* 拷贝构造赋值函数

可以通过C++11新特性`=delete`来禁用这些函数或将其声明为私有并设为default

```C++
#include<iostream>
/// <summary>
/// 影响一个类产生多个对象的函数：
/// 构造函数、拷贝构造函数、拷贝构造赋值函数
/// 使用=delete来禁用函数 或将其声明为私有
/// </summary>
class TaskQueue
{
public:
	static TaskQueue* getTaskQueue()
	{
		return m_task;
	}
private:
	TaskQueue() = default;
	TaskQueue(const TaskQueue& task) = default;
	TaskQueue& operator= (const TaskQueue& task) = default;
	static TaskQueue* m_task;
};

TaskQueue* TaskQueue::m_task = new TaskQueue();

int main()
{
	TaskQueue* a = TaskQueue::getTaskQueue();
}
```



在类外的作用域，即使构造函数是私有的，也可以对静态类进行初始化：

* 当定义或声明了一个静态成员变量时，实际上是在全局范围内创建了一个**全局变量**，而不是在类的实例化过程中创建，又由于构造对象仅用于对象的实例化，所以该静态类初始化不受构造函数限制；
* 静态成员变量的初始化是由编译器和运行时系统负责初始化的；



单例模式有两种处理模式：饿汉模式和懒汉模式

饿汉模式是一开始就声明单例，懒汉模式是用到的时候才会声明；

# 观察者模式

定义了**对象**间的一对多的组合关系，以便于一个对象的状态发生变化时，所有依赖于它的对象都得到通知和刷新。

思路：

```
1.设定两个类，一个是被观察类，一个是观察类
2.在观察类中，定义一个对某个事件感兴趣的处理函数，即槽函数
3.被观察类中，定义一个数据结构，用来保存观察者对哪一个事件id感兴趣
4.被观察者类中，定义两个方法函数
	方法1：添加观察者与其感兴趣的事件id加入到容器之中
	方法2：便利容器，有没有感兴趣的事件ID，有，则代表一系列的观察者，对这个事件感兴趣，则再次遍历观察者列表，让每一个观察者执行相	应的槽函数
```



```C++
#include<iostream>
#include<vector>

template<typename TParam>
class SlotBase
{
public:
	virtual void slotFunction(TParam param) = 0;
	virtual ~SlotBase() = default;
};

//槽类
template<typename TReciver,typename TParam>
class Slot :public SlotBase<TParam>
{
private:
	TReciver* m_pReciver;//接收者指针
	void (TReciver::* m_func)(TParam param);//接收者类中的函数指针
public:
	Slot(TReciver* pObj, void (TReciver::* func)(TParam))
	{
		//是否可以使用初始化列表
		//使用类外的接收者函数初始化
		this->m_pReciver = pObj;
		this->m_func = func;
	}

	void slotFunction(TParam param) override
	{
		//成员对象指针调用类内的成员函数
		(m_pReciver->*m_func)(param);
	}
};

//信号类
template<typename TParam>
class Signal
{
private:
	std::vector<SlotBase<TParam>*> signal_vector;//添加基类
public:
	template<typename TReciver>
	void addSlot(TReciver* pObj, void (TReciver::* func)(TParam))
	{
		signal_vector.push_back(new Slot<TReciver,TParam>(pObj,func));
	}

	void operator()(TParam param)
	{
		//用auto是否可以？
		//for (SlotBase<TParam>* p : signal_vector)
		for (auto p : signal_vector)
		{
			p->slotFunction(param);
		}
	}
};

class Reciver1
{
public:
	void func(int param)
	{
		std::cout << "这是Reciver1中的方法，参数为：" << param << std::endl;
	}
};
class Reciver2
{
public:
	void func(int param)
	{
		std::cout << "这是Reciver2中的方法，参数为：" << param << std::endl;
	}
};


class SendObj
{
public:
	Signal<int> valueChanged;
public:
	void testSignal(int value)
	{
		valueChanged(value);
	}
};

#define connect(sender,signal,reciver,method) (sender)->signal.addSlot(reciver,method)

int main()
{
	Reciver1* r1 = new Reciver1;
	Reciver2* r2 = new Reciver2;

	SendObj* sd = new SendObj;

	connect(sd, valueChanged, r1, &Reciver1::func);
	connect(sd, valueChanged, r2, &Reciver2::func);

	sd->testSignal(1000000);
}
```

