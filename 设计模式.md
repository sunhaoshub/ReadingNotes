# UML类图的画法

unified modeling language

设计程序之前画

![image-20240203164356236](C:\Users\sunha\Desktop\book\ReadingNotes\设计模式.assets\image-20240203164356236.png)

上层是类名，中间层是类的成员变量，下层是类的方法

* 可见性：+表示public，-表示private，#表示protected，_(下划线)表示静态

* 属性的表示方式：【可见性】【变量名】:【类型】(=【默认值】，括号内容可不写)
* 方法的表示方式：【可见性】【方法名】(【参数列表】):【返回类型】

纯虚函数，类名用斜体

# 类与类之间的关系（5）

## 继承关系

用一条空心箭头实线链接两个类，箭头方向指向父类

## 关联关系

一个类是另一个类的**成员变量**

单向关联、双向关联、自关联

带箭头或不带箭头的实线连接（箭头有无取决于画图软件）

自关联自己指向自己

## 聚合关系

整体被析构了，成员没有被析构；

例子：汽车与轮胎、引擎、车灯

用空心菱形直线表示，菱形指向整体；

### 代码实现聚合关系

成员对象以构造方法、Setter方法的方式注入到整体对象中，因为成员对象可以脱离整体对象独立存在

## 组合关系

当整体被析构时，部分也随之析构

带实心的菱形

## 依赖关系

1.将一个类的对象作为另一个类中**方法的参数**

2.在一个类中的方法将另一个类的对象作为**局部变量**

3.在一个类中调用另一个类的**静态方法**



用带箭头的虚线表示



依赖指向被依赖 

## 关系强弱

继承＞组合＞聚合＞关联＞依赖

# 设计模式的三个基本原则 

## 单一原则

将单一事物抽象成类

## 开放封闭原则

在封装旧的类的时候预留一些接口

多态

## 依赖倒转原则

1.高层模块不应该依赖于低层模块，两个都应该依赖于抽象

2.抽象不应该依赖于细节，细节应该依赖抽象

解释：

* 高层模块：可以理解为上层应用，就是业务层的实现
* 低层模块：底层接口，如封装好的API，动态库等
* 抽象：抽象类或接口，C++中只有抽象类

# 单例模式和任务队列

只能有一个实例对象

队列中存储任务函数（的地址）或可调用对象

典型的应用就是任务队列

用单例来代替全局变量，全局变量会破坏类的封装（全局变量可以随意被修改）

涉及到一个类多个对象的函数有：

* 构造函数
* 拷贝构造函数
* 拷贝构造赋值函数

可以通过C++11新特性`=delete`来禁用这些函数或将其声明为私有并设为default

```C++
#include<iostream>
/// <summary>
/// 影响一个类产生多个对象的函数：
/// 构造函数、拷贝构造函数、拷贝构造赋值函数
/// 使用=delete来禁用函数 或将其声明为私有
/// </summary>
class TaskQueue
{
public:
	static TaskQueue* getTaskQueue()
	{
		return m_task;
	}
private:
	TaskQueue() = default;
	TaskQueue(const TaskQueue& task) = default;
	TaskQueue& operator= (const TaskQueue& task) = default;
	static TaskQueue* m_task;
};

TaskQueue* TaskQueue::m_task = new TaskQueue();

int main()
{
	TaskQueue* a = TaskQueue::getTaskQueue();
}
```



在类外的作用域，即使构造函数是私有的，也可以对静态类进行初始化：

* 当定义或声明了一个静态成员变量时，实际上是在全局范围内创建了一个**全局变量**，而不是在类的实例化过程中创建，又由于构造对象仅用于对象的实例化，所以该静态类初始化不受构造函数限制；
* 静态成员变量的初始化是由编译器和运行时系统负责初始化的；



单例模式有两种处理模式：饿汉模式和懒汉模式

饿汉模式是一开始就声明单例，懒汉模式是用到的时候才会声明；

# 观察者模式



当发布对象的事件更新时，通知所有的订阅者，使得订阅者能够自动更新（被动获取，发布者主动通知）；

如：菜鸟驿站、微博

![image-20230113013758723](https://subingwen.cn/design-patterns/observer/image-20230113013758723.png)

定义了**对象**间的一对多的组合关系，以便于一个对象的状态发生变化时，所有依赖于它的对象都得到通知和刷新。

思路：

```
1.设定两个类，一个是被观察类，一个是观察类
2.在观察类中，定义一个对某个事件感兴趣的处理函数，即槽函数
3.被观察类中，定义一个数据结构，用来保存观察者对哪一个事件id感兴趣
4.被观察者类中，定义两个方法函数
	方法1：添加观察者与其感兴趣的事件id加入到容器之中
	方法2：便利容器，有没有感兴趣的事件ID，有，则代表一系列的观察者，对这个事件感兴趣，则再次遍历观察者列表，让每一个观察者执行相	应的槽函数
```



```C++
#include<iostream>
#include<vector>

template<typename TParam>
class SlotBase
{
public:
	virtual void slotFunction(TParam param) = 0;
	virtual ~SlotBase() = default;
};

//槽类
template<typename TReciver,typename TParam>
class Slot :public SlotBase<TParam>
{
private:
	TReciver* m_pReciver;//接收者指针
	void (TReciver::* m_func)(TParam param);//接收者类中的函数指针
public:
	Slot(TReciver* pObj, void (TReciver::* func)(TParam))
	{
		//是否可以使用初始化列表
		//使用类外的接收者函数初始化
		this->m_pReciver = pObj;
		this->m_func = func;
	}

	void slotFunction(TParam param) override
	{
		//成员对象指针调用类内的成员函数
		(m_pReciver->*m_func)(param);
	}
};

//信号类
template<typename TParam>
class Signal
{
private:
	std::vector<SlotBase<TParam>*> signal_vector;//添加基类
public:
	template<typename TReciver>
	void addSlot(TReciver* pObj, void (TReciver::* func)(TParam))
	{
		signal_vector.push_back(new Slot<TReciver,TParam>(pObj,func));
	}

	void operator()(TParam param)
	{
		//可以用auto
		//for (SlotBase<TParam>* p : signal_vector)
		for (auto p : signal_vector)
		{
			p->slotFunction(param);
		}
	}
};

class Reciver1
{
public:
	void func(int param)
	{
		std::cout << "这是Reciver1中的方法，参数为：" << param << std::endl;
	}
};
class Reciver2
{
public:
	void func(int param)
	{
		std::cout << "这是Reciver2中的方法，参数为：" << param << std::endl;
	}
};


class SendObj
{
public:
	Signal<int> valueChanged;
public:
	void testSignal(int value)
	{
		valueChanged(value);
	}
};

#define connect(sender,signal,reciver,method) (sender)->signal.addSlot(reciver,method)

int main()
{
	Reciver1* r1 = new Reciver1;
	Reciver2* r2 = new Reciver2;

	SendObj* sd = new SendObj;

	connect(sd, valueChanged, r1, &Reciver1::func);
	connect(sd, valueChanged, r2, &Reciver2::func);

	sd->testSignal(1000000);
}
```

# 工厂模式

* 简单工厂模式、工厂模式、抽象工厂模式
* 工厂的作用是生产对象，好处是我们（通过工厂生产对象的对象）不需要担心生产细节问题和产品（生产出的对象）的质量问题

## 简单工厂模式

```C++
#include<iostream>

//产品基类
class AbstractSmile
{
public:
	virtual void transform() = 0;
	virtual void ability() = 0;
	virtual ~AbstractSmile() {};
};

class SheepSmile :public AbstractSmile
{
public:
	void transform() override
	{
		std::cout << "变成人兽 -- 山羊人形态..." << std::endl;
	}

	void ability() override
	{
		std::cout << "将手臂变成绵羊角的招式 -- 巨羊角" << std::endl;
	}
};

class LionSmile :public AbstractSmile
{
public:
	void transform() override
	{
		std::cout << "变成人兽 -- 狮子人形态..." << std::endl;
	}

	void ability() override
	{
		std::cout << "遁· 豪火球之术..." << std::endl;
	}
};
class BatSmile :public AbstractSmile
{
public:
	void transform() override
	{
		std::cout << "变成人兽 -- 蝙蝠人形态..." << std::endl;
	}

	void ability() override
	{
		std::cout << "声纳引箭之万剑归宗..." << std::endl;
	}
};

enum class Type:char {Sheep,Lion,Bat};

//工厂类
class SmileFactory {
public:
	AbstractSmile* createSmile(Type type)
	{
		AbstractSmile* ptr = nullptr;
		switch (type)
		{
		case (Type::Sheep):
			ptr = new SheepSmile;
			break;
		case(Type::Lion):
			ptr = new LionSmile;
			break;
		case(Type::Bat):
			ptr = new BatSmile;
			break;
		default:
			break;
		}

		return ptr;
	}
};

int main()
{
	SmileFactory* factory = new SmileFactory;
	AbstractSmile* smile =  factory->createSmile(Type::Sheep);
	smile->transform();
	smile->ability();

	return 0;
}
```

## 工厂模式

N个工厂类，一个子工厂类生产一类对象，维护了封闭原则（不修改已有类）

```C++
#include<iostream>

//产品基类
class AbstractSmile
{
public:
	virtual void transform() = 0;
	virtual void ability() = 0;
	virtual ~AbstractSmile() {};
};

class SheepSmile :public AbstractSmile
{
public:
	void transform() override
	{
		std::cout << "变成人兽 -- 山羊人形态..." << std::endl;
	}

	void ability() override
	{
		std::cout << "将手臂变成绵羊角的招式 -- 巨羊角" << std::endl;
	}
};

class LionSmile :public AbstractSmile
{
public:
	void transform() override
	{
		std::cout << "变成人兽 -- 狮子人形态..." << std::endl;
	}

	void ability() override
	{
		std::cout << "遁· 豪火球之术..." << std::endl;
	}
};
class BatSmile :public AbstractSmile
{
public:
	void transform() override
	{
		std::cout << "变成人兽 -- 蝙蝠人形态..." << std::endl;
	}

	void ability() override
	{
		std::cout << "声纳引箭之万剑归宗..." << std::endl;
	}
};

enum class Type:char {Sheep,Lion,Bat};

//工厂类
class SmileFactory {
public:
	 virtual AbstractSmile* createSmile()=0;
	 virtual ~SmileFactory()
	 {
		 std::cout << "SmileFactory Destructor..." << std::endl;
	 }
};

class SheepFactory : public SmileFactory
{
public:
	SheepFactory() {};
	~SheepFactory() {
		std::cout << "SheepFactory Destructor..." << std::endl;
	}
	AbstractSmile* createSmile() override
	{
		return new SheepSmile;
	}
};
class LionFactory : public SmileFactory
{
public:
	LionFactory() {};
	~LionFactory() {
		std::cout << "LionFactory Destructor..." << std::endl;
	}
	AbstractSmile* createSmile() override
	{
		return new LionSmile;
	}
};
class BatFactory : public SmileFactory
{
public:
	BatFactory() {};
	~BatFactory() {
		std::cout << "BatFactory Destructor..." << std::endl;
	}
	AbstractSmile* createSmile() override
	{
		return new BatSmile;
	}
};
int main()
{
	SmileFactory* factory = new LionFactory;
	AbstractSmile* smile =  factory->createSmile();
	smile->transform();
	smile->ability();

	delete smile;
	delete factory;

	return 0;
}
```

## 抽象工厂模式

组合、聚合

```C++
#include<iostream>
#include<string>

using namespace std;

//船体
class ShipBody
{
public:
	virtual string getShipBody() = 0;
	virtual ~ShipBody() {};
};
class WoodBody :public ShipBody
{
public:
	string getShipBody() override
	{
		return "用<木材>制作轮船船体..." ;
	}
};
class IronBody :public ShipBody
{
public:
	string getShipBody() override
	{
		return "用<钢铁>制作轮船船体..." ;
	}
};
class MetalBody :public ShipBody
{
public:
	string getShipBody() override
	{
		return "用<合金>制作轮船船体..." ;
	}
};
//动力
class Engine
{
public:
	virtual string getEngine() = 0;
	virtual ~Engine() {};
};
class Human : public Engine
{
public:
	string getEngine() override
	{
		return string("使用<人力驱动>...");
	}
};

class Diesel : public Engine
{
public:
	string getEngine() override
	{
		return string("使用<内燃机驱动>...");
	}
};

class Nuclear : public Engine
{
public:
	string getEngine() override
	{
		return string("使用<核能驱动>...");
	}
};

//武器
class Weapon
{
public:
	virtual string getWeapon() = 0;
	virtual ~Weapon() {}
};

class Gun : public Weapon
{
public:
	string getWeapon() override
	{
		return string("配备的武器是<枪>...");
	}
};

class Cannon : public Weapon
{
public:
	string getWeapon() override
	{
		return string("配备的武器是<自动机关炮>...");
	}
};

class Laser : public Weapon
{
public:
	string getWeapon() override
	{
		return string("配备的武器是<激光>...");
	}
};

//组装成船
class Ship
{
private:
	ShipBody* m_shipbody;
	Engine* m_engine;
	Weapon* m_weapon;
public:
	Ship(ShipBody* body, Weapon* weapon,Engine* engine):
		m_shipbody(body),m_engine(engine),m_weapon(weapon){}
	 ~Ship() {
		 delete m_shipbody;
		 delete m_engine;
		 delete m_weapon;
	};

	 string getProperty()
	 {
		 return m_shipbody->getShipBody() + m_engine->getEngine() + m_weapon->getWeapon();
	 }
};

//工厂
// 工厂类
class AbstractFactory
{
public:
	virtual Ship* createShip() = 0;
	virtual ~AbstractFactory() {}
};

class BasicFactory : public AbstractFactory
{
public:
	Ship* createShip() override
	{
		Ship* ship = new Ship(new WoodBody, new Gun, new Human);
		cout << "<基础型>战船生产完毕, 可以下水啦..." << endl;
		return ship;
	}
};

class StandardFactory : public AbstractFactory
{
public:
	Ship* createShip() override
	{
		Ship* ship = new Ship(new IronBody, new Cannon, new Diesel);
		cout << "<标准型>战船生产完毕, 可以下水啦..." << endl;
		return ship;
	}
};

class UltimateFactory : public AbstractFactory
{
public:
	Ship* createShip() override
	{
		Ship* ship = new Ship(new MetalBody, new Laser, new Nuclear);
		cout << "<旗舰型>战船生产完毕, 可以下水啦..." << endl;
		return ship;
	}
};
int main()
{
	AbstractFactory* factroy = new StandardFactory;
	Ship* ship = factroy->createShip();
	cout << ship->getProperty();
	delete ship;
	delete factroy;
	return 0;
}
```

# 状态模式

* 各个状态之间存在一定的关联
* 在抽象状态类中实现工作函数
