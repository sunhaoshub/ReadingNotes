# UML类图的画法

unified modeling language

设计程序之前画

![image-20240203164356236](C:\Users\sunha\Desktop\book\ReadingNotes\设计模式.assets\image-20240203164356236.png)

上层是类名，中间层是类的成员变量，下层是类的方法

* 可见性：+表示public，-表示private，#表示protected，_(下划线)表示静态

* 属性的表示方式：【可见性】【变量名】:【类型】(=【默认值】，括号内容可不写)
* 方法的表示方式：【可见性】【方法名】(【参数列表】):【返回类型】

纯虚函数，类名用斜体

# 类与类之间的关系（5）

## 继承关系

用一条空心箭头实线链接两个类，箭头方向指向父类

## 关联关系

一个类是另一个类的**成员变量**

单向关联、双向关联、自关联

带箭头或不带箭头的实线连接（箭头有无取决于画图软件）

自关联自己指向自己

## 聚合关系

整体被析构了，成员没有被析构；

例子：汽车与轮胎、引擎、车灯

用空心菱形直线表示，菱形指向整体；

### 代码实现聚合关系

成员对象以构造方法、Setter方法的方式注入到整体对象中，因为成员对象可以脱离整体对象独立存在

## 组合关系

当整体被析构时，部分也随之析构

带实心的菱形

## 依赖关系

1.将一个类的对象作为另一个类中**方法的参数**

2.在一个类中的方法将另一个类的对象作为**局部变量**

3.在一个类中调用另一个类的**静态方法**



用带箭头的虚线表示



依赖指向被依赖 

## 关系强弱

继承＞组合＞聚合＞关联＞依赖

# 设计模式的三个基本原则 

## 单一原则

将单一事物抽象成类

## 开放封闭原则

在封装旧的类的时候预留一些接口

多态

## 依赖倒转原则

1.高层模块不应该依赖于低层模块，两个都应该依赖于抽象

2.抽象不应该依赖于细节，细节应该依赖抽象

解释：

* 高层模块：可以理解为上层应用，就是业务层的实现
* 低层模块：底层接口，如封装好的API，动态库等
* 抽象：抽象类或接口，C++中只有抽象类

# 单例模式和任务队列

只能有一个实例对象

队列中存储任务函数（的地址）或可调用对象

典型的应用就是任务队列

用单例来代替全局变量，全局变量会破坏类的封装（全局变量可以随意被修改）

涉及到一个类多个对象的函数有：

* 构造函数
* 拷贝构造函数
* 拷贝构造赋值函数

可以通过C++11新特性`=delete`来禁用这些函数或将其声明为私有并设为default

```C++
#include<iostream>
/// <summary>
/// 影响一个类产生多个对象的函数：
/// 构造函数、拷贝构造函数、拷贝构造赋值函数
/// 使用=delete来禁用函数 或将其声明为私有
/// </summary>
class TaskQueue
{
public:
	static TaskQueue* getTaskQueue()
	{
		return m_task;
	}
private:
	TaskQueue() = default;
	TaskQueue(const TaskQueue& task) = default;
	TaskQueue& operator= (const TaskQueue& task) = default;
	static TaskQueue* m_task;
};

TaskQueue* TaskQueue::m_task = new TaskQueue();

int main()
{
	TaskQueue* a = TaskQueue::getTaskQueue();
}
```



在类外的作用域，即使构造函数是私有的，也可以对静态类进行初始化：

* 当定义或声明了一个静态成员变量时，实际上是在全局范围内创建了一个**全局变量**，而不是在类的实例化过程中创建，又由于构造对象仅用于对象的实例化，所以该静态类初始化不受构造函数限制；
* 静态成员变量的初始化是由编译器和运行时系统负责初始化的；



单例模式有两种处理模式：饿汉模式和懒汉模式

饿汉模式是一开始就声明单例，懒汉模式是用到的时候才会声明；

